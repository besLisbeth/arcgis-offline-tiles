(function(){(this||window).webpackJsonp.registerAbsMids({"esri/views/2d/engine/webgl/BitBlitRenderer":"+P5t","esri/views/2d/engine/webgl/shaders/BitBlitPrograms":"/2xn","esri/views/webgl/FramebufferObject":"/f24","esri/views/vectorTiles/Rect":"2ZMW","esri/views/vectorTiles/RenderBucket":"3JFk","esri/core/libs/gl-matrix-2/factories/vec4f32":"3gjc","esri/views/vectorTiles/renderers/Renderer":"5iPT","esri/views/vectorTiles/RectangleBinPack":"66Fz","esri/views/vectorTiles/renderers/IconRenderer":"7ha9","esri/core/requireUtils":"ADZV","esri/views/vectorTiles/renderers/shaders/sources/shaderRepository":"Ak4l","esri/views/vectorTiles/VectorTileDisplayObject":"AvrD","esri/views/vectorTiles/GlyphSource":"B7Pw","esri/views/2d/engine/DisplayObject":"Brhx","esri/views/vectorTiles/GlyphMosaic":"Ix/S","esri/views/vectorTiles/renderers/LineRenderer":"RR1D","esri/views/vectorTiles/renderers/CircleRenderer":"RkId","esri/views/webgl/Renderbuffer":"Rrc3","esri/views/vectorTiles/MemoryBuffer":"U+RI","esri/views/vectorTiles/TileHandler":"U6PA","esri/views/2d/engine/webgl/shaders/sources/shaderRepository":"Uu9s","esri/views/vectorTiles/renderers/SymbolRenderer":"VyQn","esri/views/webgl/Texture":"Zp3t","esri/views/vectorTiles/SpriteMosaic":"c8HX","esri/views/vectorTiles/renderers/TileInfoRenderer":"dHDC","esri/views/2d/engine/webgl/shaders/sources/resolver":"hPTP","esri/views/vectorTiles/renderers/shaders/sources/resolver":"hmBC","esri/core/libs/gl-matrix-2/vec4f32":"j2SP","esri/views/vectorTiles/renderers/shaders/ProgramCache":"jImx","esri/views/vectorTiles/renderers/FadeRecorder":"lOe/","esri/views/vectorTiles/renderers/rendererUtils":"lr+P","esri/views/vectorTiles/renderers/FillRenderer":"meDW","esri/views/vectorTiles/renderers/SDFRenderer":"suZm","esri/views/vectorTiles/renderers/BackgroundRenderer":"v4bN","esri/core/pbf":"v7zm","esri/views/vectorTiles/renderers/shaders/Programs":"y1Ek"})})(),(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{"+P5t":function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("/2xn"),i("QFi0"),i("U+8K"),i("z2+Q")],void 0===(r=function(e,t,i,n,r,a){return function(){function e(){this._initialized=!1}return e.prototype.dispose=function(){this._program&&(this._program.dispose(),this._program=null),this._vertexArrayObject&&(this._vertexArrayObject.dispose(),this._vertexArrayObject=null)},e.prototype.render=function(e,t,i,n){e&&(this._initialized||this._initialize(e),e.setBlendFunctionSeparate(1,771,1,771),e.bindVAO(this._vertexArrayObject),e.bindProgram(this._program),t.setSamplingMode(i),e.bindTexture(t,0),this._program.setUniform1i("u_tex",0),this._program.setUniform1f("u_opacity",n),e.drawArrays(5,0,4),e.bindVAO())},e.prototype._initialize=function(e){if(this._initialized)return!0;var t=i.bitBlit.attributes,o=r.createProgram(e,i.bitBlit);if(!o)return!1;var s=new Int8Array(16);s[0]=-1,s[1]=-1,s[2]=0,s[3]=0,s[4]=1,s[5]=-1,s[6]=1,s[7]=0,s[8]=-1,s[9]=1,s[10]=0,s[11]=1,s[12]=1,s[13]=1,s[14]=1,s[15]=1;var l=new a(e,t,{geometry:[{name:"a_pos",count:2,type:5120,offset:0,stride:4,normalized:!1,divisor:0},{name:"a_tex",count:2,type:5120,offset:2,stride:4,normalized:!1,divisor:0}]},{geometry:n.createVertex(e,35044,s)});return this._program=o,this._vertexArrayObject=l,this._initialized=!0},e}()}.apply(null,n))||(e.exports=r)},"/2xn":function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("hPTP")],void 0===(r=function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0}),t.bitBlit={name:"bitBlit",shaders:{vertexShader:i.resolveIncludes("bitBlit/bitBlit.vert"),fragmentShader:i.resolveIncludes("bitBlit/bitBlit.frag")},attributes:{a_pos:0,a_tex:1}}}.apply(null,n))||(e.exports=r)},"/f24":function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("H1tY"),i("Rrc3"),i("Zp3t")],void 0===(r=function(e,t,i,n,r){return function(){function e(t,a,o,s){if(this._context=null,this._glName=null,this._depthAttachment=null,this._stencilAttachment=null,this._colorAttachment=null,this._initialized=!1,this._context=t,this._desc={colorTarget:a.colorTarget,depthStencilTarget:a.depthStencilTarget,width:a.width,height:a.height,multisampled:a.multisampled},this._id=e._nextId++,i("esri-webgl-debug")&&t.instanceCounter.incrementCount(4),o){var l=void 0;o instanceof r?(this._colorAttachment=o,l=o.descriptor):(l=o,this._colorAttachment=new r(this._context,l)),this._desc.colorTarget,e._validateTextureDimensions(l,this._desc)}if(s instanceof n)2===a.depthStencilTarget?this._stencilAttachment=s:(1===a.depthStencilTarget||3===a.depthStencilTarget)&&(this._depthAttachment=s),e._validateBufferDimensions(s.descriptor,this._desc);else if(s){this._context.capabilities.depthTexture;var d=void 0;s instanceof r?(this._depthStencilTexture=s,d=this._depthStencilTexture.descriptor):(d=s,this._depthStencilTexture=new r(this._context,d)),e._validateTextureDimensions(d,this._desc)}}return e.create=function(t,i){return new e(t,i)},e.createWithAttachments=function(t,i,n,r){return new e(t,n,i,r)},Object.defineProperty(e.prototype,"id",{get:function(){return this._id},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"glName",{get:function(){return this._glName},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"descriptor",{get:function(){return this._desc},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"colorTexture",{get:function(){return this._colorAttachment instanceof r?this._colorAttachment:null},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"colorAttachment",{get:function(){return this._colorAttachment},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"depthStencilAttachment",{get:function(){return this._depthStencilTexture||this._depthAttachment||this._stencilAttachment},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"depthStencilTexture",{get:function(){return this._depthStencilTexture},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"width",{get:function(){return this._desc.width},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"height",{get:function(){return this._desc.height},enumerable:!0,configurable:!0}),e.prototype.dispose=function(){if(this._context){var e=this._context,t=e.getBoundFramebufferObject();this._disposeColorAttachment(),this._disposeDepthStencilAttachments(),this._glName&&(e.gl.deleteFramebuffer(this._glName),this._glName=null),i("esri-webgl-debug")&&e.instanceCounter.decrementCount(4),e.bindFramebuffer(t),this._context=null}},e.prototype.attachColorTexture=function(t){if(t){var i=t.descriptor;if(e._validateTextureDimensions(i,this._desc),this._disposeColorAttachment(),this._initialized){this._context.bindFramebuffer(this);var n=this._context.gl;n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t.glName,0)}this._colorAttachment=t}},e.prototype.detachColorTexture=function(){var e=void 0;if(this._colorAttachment instanceof r){if(e=this._colorAttachment,this._initialized){this._context.bindFramebuffer(this);var t=this._context.gl;this._context.gl.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0)}this._colorAttachment=null}return e},e.prototype.attachDepthStencilTexture=function(t){if(t){var i=t.descriptor;if(i.pixelFormat,i.dataType,this._context.capabilities.depthTexture,e._validateTextureDimensions(i,this._desc),4!==this._desc.depthStencilTarget&&(this._desc.depthStencilTarget=4),this._disposeDepthStencilAttachments(),this._initialized){this._context.bindFramebuffer(this);var n=this._context.gl;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,t.glName,0)}this._depthStencilTexture=t}},e.prototype.detachDepthStencilTexture=function(){var e=this._depthStencilTexture;if(e&&this._initialized){this._context.bindFramebuffer(this);var t=this._context.gl;this._context.gl.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,null,0)}return this._depthStencilTexture=null,e},e.prototype.attachDepthStencilBuffer=function(t){if(t){var i=t.descriptor;if(34041!==i.internalFormat&&i.internalFormat,e._validateBufferDimensions(i,this._desc),this._disposeDepthStencilAttachments(),this._desc.depthStencilTarget=34041===i.internalFormat?3:1,this._initialized){this._context.bindFramebuffer(this);var n=this._context.gl,r=1===this._desc.depthStencilTarget?n.DEPTH_ATTACHMENT:n.DEPTH_STENCIL_ATTACHMENT;n.framebufferRenderbuffer(n.FRAMEBUFFER,r,n.RENDERBUFFER,t.glName)}this._depthAttachment=t}},e.prototype.detachDepthStencilBuffer=function(){var e=this._context.gl,t=this._depthAttachment;if(t&&this._initialized){this._context.bindFramebuffer(this);var i=1===this._desc.depthStencilTarget?e.DEPTH_ATTACHMENT:e.DEPTH_STENCIL_ATTACHMENT;e.framebufferRenderbuffer(e.FRAMEBUFFER,i,e.RENDERBUFFER,null)}return this._depthAttachment=null,t},e.prototype.copyToTexture=function(e,t,i,n,r,a,o){var s=this._desc,l=o.descriptor;o.descriptor.target,e+i>s.width||t+n>s.height||r+i>l.width||l.height;var d=this._context;d.bindTexture(o),d.bindFramebuffer(this),d.gl.copyTexSubImage2D(3553,0,r,a,e,t,i,n)},e.prototype.readPixels=function(e,t,i,n,r,a,o){this._context.bindFramebuffer(this),this._context.gl.readPixels(e,t,i,n,r,a,o)},e.prototype.resize=function(t,i){var n=this._desc;if(n.width!==t||n.height!==i){if(!this._initialized){if(n.width=t,n.height=i,this._colorAttachment instanceof r)(a=this._colorAttachment).resize(t,i);return void(this._depthStencilTexture&&this._depthStencilTexture.resize(t,i))}var a,o;if(n.width=t,n.height=i,this._colorAttachment instanceof r)(o=(a=this._colorAttachment).descriptor).width=t,o.height=i,this._colorAttachment.dispose(),this._colorAttachment=new r(this._context,o),e._validateTextureDimensions(a.descriptor,this._desc);else this._colorAttachment&&this._disposeColorAttachment();if(null!=this._depthStencilTexture)(o=this._depthStencilTexture.descriptor).width=t,o.height=i,this._depthStencilTexture.dispose(),this._depthStencilTexture=new r(this._context,o);else(this._depthAttachment||this._stencilAttachment)&&this._disposeDepthStencilAttachments();this._context.getBoundFramebufferObject()===this&&this._context.bindFramebuffer(null),this._initialized=!1}},e.prototype.initialize=function(){if(this._initialized)return!1;var e=this._context.gl;this._glName&&e.deleteFramebuffer(this._glName);var t=e.createFramebuffer(),i=this._desc;if(e.bindFramebuffer(e.FRAMEBUFFER,t),!this._colorAttachment)if(0===i.colorTarget){var a={target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728,wrapMode:33071,width:i.width,height:i.height};this._colorAttachment=new r(this._context,a)}else{var o=new n(this._context,{internalFormat:32854,width:i.width,height:i.height});e.framebufferRenderbuffer(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.RENDERBUFFER,o.glName),this._colorAttachment=o}if(this._colorAttachment instanceof r){var s=this._colorAttachment;e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,s.glName,0)}switch(i.depthStencilTarget){case 1:case 3:this._depthAttachment||(this._depthAttachment=new n(this._context,{internalFormat:1===i.depthStencilTarget?33189:34041,width:i.width,height:i.height}));var l=1===i.depthStencilTarget?e.DEPTH_ATTACHMENT:e.DEPTH_STENCIL_ATTACHMENT;e.framebufferRenderbuffer(e.FRAMEBUFFER,l,e.RENDERBUFFER,this._depthAttachment.glName);break;case 2:this._stencilAttachment||(this._stencilAttachment=new n(this._context,{internalFormat:36168,width:i.width,height:i.height})),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.STENCIL_ATTACHMENT,e.RENDERBUFFER,this._stencilAttachment.glName);break;case 4:if(!this._depthStencilTexture){this._context.capabilities.depthTexture;var d={target:3553,pixelFormat:34041,dataType:34042,samplingMode:9728,wrapMode:33071,width:i.width,height:i.height};this._depthStencilTexture=new r(this._context,d)}e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.TEXTURE_2D,this._depthStencilTexture.glName,0)}return e.checkFramebufferStatus(e.FRAMEBUFFER),e.FRAMEBUFFER_COMPLETE,this._glName=t,this._initialized=!0,!0},e.prototype._disposeColorAttachment=function(){if(this._colorAttachment instanceof r){var e=this._colorAttachment;if(this._initialized)this._context.bindFramebuffer(this),(i=this._context.gl).framebufferTexture2D(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.TEXTURE_2D,null,0);e.dispose()}else if(this._colorAttachment instanceof WebGLRenderbuffer){var t=this._colorAttachment,i=this._context.gl;this._initialized&&(this._context.bindFramebuffer(this),i.framebufferRenderbuffer(i.FRAMEBUFFER,i.COLOR_ATTACHMENT0,i.RENDERBUFFER,null)),this._context.gl.deleteRenderbuffer(t)}this._colorAttachment=null},e.prototype._disposeDepthStencilAttachments=function(){var e=this._context.gl;if(this._depthAttachment){if(this._initialized){this._context.bindFramebuffer(this);var t=1===this._desc.depthStencilTarget?e.DEPTH_ATTACHMENT:e.DEPTH_STENCIL_ATTACHMENT;e.framebufferRenderbuffer(e.FRAMEBUFFER,t,e.RENDERBUFFER,null)}this._depthAttachment.dispose(),this._depthAttachment=null}this._stencilAttachment&&(this._initialized&&(this._context.bindFramebuffer(this),e.framebufferRenderbuffer(e.FRAMEBUFFER,e.STENCIL_ATTACHMENT,e.RENDERBUFFER,null)),this._stencilAttachment.dispose(),this._stencilAttachment=null),this._depthStencilTexture&&(this._initialized&&(this._context.bindFramebuffer(this),e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_STENCIL_ATTACHMENT,e.TEXTURE_2D,null,0)),this._depthStencilTexture.dispose(),this._depthStencilTexture=null)},e._validateBufferDimensions=function(e,t){void 0!==t.width&&t.width>=0&&void 0!==t.height&&t.height>=0?t.width===e.width&&(t.height,e.height):(t.width=e.width,t.height=e.height)},e._validateTextureDimensions=function(e,t){e.target,void 0!==t.width&&t.width>=0&&void 0!==t.height&&t.height>=0?t.width===e.width&&(t.height,e.height):(t.width=e.width,t.height=e.height)},e._nextId=0,e}()}.apply(null,n))||(e.exports=r)},"2ZMW":function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){return function(){function e(e,t,i,n){void 0===e&&(e=0),void 0===t&&(t=0),void 0===i&&(i=0),void 0===n&&(n=0),this.x=e,this.y=t,this.width=i,this.height=n}return Object.defineProperty(e.prototype,"isEmpty",{get:function(){return this.width<=0||this.height<=0},enumerable:!0,configurable:!0}),e}()}.apply(null,n))||(e.exports=r)},"3JFk":function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("xhoE"),i("qKT0")],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=function(e){this.type=e};t.RenderBucket=r;var a=function(e){function t(){var t=e.call(this,2)||this;return t.triangleElementStart=0,t.triangleElementCount=0,t}return i(t,e),t.prototype.hasData=function(){return this.triangleElementCount>0},t}(r);t.LineRenderBucket=a;var o=function(e){function t(){var t=e.call(this,1)||this;return t.triangleElementStart=0,t.triangleElementCount=0,t.outlineElementStart=0,t.outlineElementCount=0,t}return i(t,e),t.prototype.hasData=function(){return this.triangleElementCount>0||this.outlineElementCount>0},t}(r);t.FillRenderBucket=o;var s=function(e){function t(){var t=e.call(this,3)||this;return t.markerPerPageElementsMap=new Map,t.glyphPerPageElementsMap=new Map,t.isSDF=!1,t}return i(t,e),t.prototype.hasData=function(){return this.markerPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0},t}(r);t.SymbolRenderBucket=s;var l=function(e){function t(){var t=e.call(this,4)||this;return t.triangleElementStart=0,t.triangleElementCount=0,t}return i(t,e),t.prototype.hasData=function(){return this.triangleElementCount>0},t}(r);t.CircleRenderBucket=l;var d=function(e){function t(){return e.call(this,0)||this}return i(t,e),t.prototype.hasData=function(){return!0},t}(r);t.BackgroundRenderBucket=d}.apply(null,n))||(e.exports=r)},"3gjc":function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.create=function(){return new Float32Array(4)},t.clone=function(e){var t=new Float32Array(4);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t},t.fromValues=function(e,t,i,n){var r=new Float32Array(4);return r[0]=e,r[1]=t,r[2]=i,r[3]=n,r},t.createView=function(e,t){return new Float32Array(e,t,4)}}.apply(null,n))||(e.exports=r)},"5iPT":function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("FXVB"),i("oZZu"),i("vlC2"),i("j2SP"),i("+P5t"),i("BEeJ"),i("v4bN"),i("RkId"),i("lOe/"),i("meDW"),i("RR1D"),i("VyQn"),i("dHDC"),i("jImx"),i("/f24")],void 0===(r=function(e,t,i,n,r,a,o,s,l,d,u,c,f,h,_,p,m){return function(){function e(){this._extrudeMatrix=n.mat4f32.create(),this._extrudeNoRotationMatrix=n.mat4f32.create(),this._extrudeRotateVector=r.vec3f32.fromValues(0,0,1),this._extrudeScaleVector=r.vec3f32.fromValues(1,1,1),this._backgroundColor=a.vec4f32.fromValues(1,0,0,1),this._state={rotation:0,size:[0,0]},this._cachedWidth=0,this._cachedHeight=0,this._cachedRotation=0,this._blitRenderer=new o,this._globalOpacityFBO=null,this._boundFBO=null,this._programCache=null}return e.prototype.initialize=function(e,t,i){void 0===i&&(i=!0),this._SpriteMosaic=e,this._glyphMosaic=t,this._ignoreSpeed=!i,this._fadeRecorder=new u.FadeRecorder(300)},e.prototype.dispose=function(){this._backgroundRenderer&&(this._backgroundRenderer.dispose(),this._backgroundRenderer=null),this._lineRenderer&&(this._lineRenderer.dispose(),this._lineRenderer=null),this._fillRenderer&&(this._fillRenderer.dispose(),this._fillRenderer=null),this._symbolRenderer&&(this._symbolRenderer.dispose(),this._symbolRenderer=null),this._circleRenderer&&(this._circleRenderer.dispose(),this._circleRenderer=null),this._tileInfoRenderer&&(this._tileInfoRenderer.dispose(),this._tileInfoRenderer=null),this._hittestFBO&&(this._hittestFBO.dispose(),this._hittestFBO=null),this._globalOpacityFBO&&(this._globalOpacityFBO.dispose(),this._globalOpacityFBO=null),this._blitRenderer&&(this._blitRenderer.dispose(),this._blitRenderer=null),this._boundFBO=null,this._programCache&&(this._programCache.dispose(),this._programCache=null),this._cachedWidth=0,this._cachedHeight=0,this._cachedRotation=0},e.prototype.initializeProgramCache=function(e){if(null===this._programCache){var t=new p.default;t.initialize(e),this._backgroundRenderer=new l(t),this._lineRenderer=new f(t),this._fillRenderer=new c(t),this._symbolRenderer=new h(t),this._circleRenderer=new d(t),this._tileInfoRenderer=new _(t),this._programCache=t}},e.prototype.setStateParams=function(e,t,n){this._fadeRecorder.recordLevel(n),this._state=e,this._state.size[0]===this._cachedWidth&&this._state.size[1]===this._cachedHeight&&this._state.rotation===this._cachedRotation||(this._extrudeScaleVector[0]=2/e.size[0],this._extrudeScaleVector[1]=-2/e.size[1],i.mat4.identity(this._extrudeMatrix),i.mat4.rotate(this._extrudeMatrix,this._extrudeMatrix,-e.rotation*s.C_DEG_TO_RAD,this._extrudeRotateVector),i.mat4.scale(this._extrudeMatrix,this._extrudeMatrix,this._extrudeScaleVector),i.mat4.transpose(this._extrudeMatrix,this._extrudeMatrix),i.mat4.identity(this._extrudeNoRotationMatrix),i.mat4.scale(this._extrudeNoRotationMatrix,this._extrudeNoRotationMatrix,this._extrudeScaleVector),i.mat4.transpose(this._extrudeNoRotationMatrix,this._extrudeNoRotationMatrix),this._cachedWidth=this._state.size[0],this._cachedHeight=this._state.size[1],this._cachedRotation=this._state.rotation)},e.prototype.drawClippingMasks=function(e,t){if(0!==t.length){e.setDepthWriteEnabled(!1),e.setDepthTestEnabled(!1),e.setStencilTestEnabled(!0),e.setBlendingEnabled(!1),e.setColorMask(!1,!1,!1,!1),e.setStencilOp(7680,7680,7681),e.setStencilWriteMask(255),e.setClearStencil(0);var i=e.gl;e.clear(i.STENCIL_BUFFER_BIT);for(var n=0,r=t;n<r.length;n++){var a=r[n];a.attached&&a.visible&&(e.setStencilFunctionSeparate(1032,519,a.stencilData.reference,a.stencilData.mask),this._backgroundRenderer.renderSolidColor(e,{u_matrix:a.tileTransform.transform,u_normalized_origin:a.tileTransform.displayCoord,u_coord_range:a.coordRange,u_depth:0,u_color:this._backgroundColor}))}e.setColorMask(!0,!0,!0,!0),e.setBlendingEnabled(!0)}},e.prototype.renderDebug=function(e,t){var i=t.key;this._backgroundColor.set([i.col%2,i.row%2,i.col%2==0&&i.row%2==0?1:0,.5]),this._backgroundRenderer.renderSolidColor(e,{u_matrix:t.tileTransform.transform,u_normalized_origin:t.tileTransform.displayCoord,u_coord_range:t.coordRange,u_depth:0,u_color:this._backgroundColor})},e.prototype.renderBucket=function(e,t,i,n,r,a,o,s){if(o&&!(void 0!==o.minzoom&&o.minzoom>i+1e-6||a.key.level===n&&void 0!==o.maxzoom&&o.maxzoom<=i-1e-6))switch(t.type){case 0:2!==r&&this._renderBackground(e,t,i,r,a,o,s);break;case 1:2!==r&&this._renderFill(e,t,i,r,a,o,s);break;case 2:1!==r&&3!==r||this._renderLine(e,t,i,r,a,o,s);break;case 3:2!==r&&3!==r||this._renderSymbol(e,t,i,r,n,a,o,s);break;case 4:2!==r&&3!==r||this._renderCircle(e,t,i,r,n,a,o,s)}},e.prototype.renderTileInfo=function(e,t){this._tileInfoRenderer.render(e,t)},e.prototype.setGlobalOpacity=function(e,t,i){if(1!==i){this._boundFBO=e.getBoundFramebufferObject();var n=t.pixelRatio,r=t.state.size,a=r[0],o=r[1],s=Math.round(a*n),l=Math.round(o*n);null!==this._globalOpacityFBO&&this._globalOpacityFBO.width===s&&this._globalOpacityFBO.height===l||(null!==this._globalOpacityFBO&&this._globalOpacityFBO.dispose(),this._globalOpacityFBO=m.create(e,{colorTarget:0,depthStencilTarget:3,width:s,height:l})),e.bindFramebuffer(this._globalOpacityFBO),e.setClearColor(0,0,0,0),e.clear(e.gl.COLOR_BUFFER_BIT)}},e.prototype.applyGlobalOpacity=function(e,t,i){if(1!==i){var n=t.pixelRatio,r=t.state.size,a=r[0],o=r[1],s=e.getViewport();e.setViewport(0,0,n*a,n*o),e.bindFramebuffer(this._boundFBO);var l=this._globalOpacityFBO.colorTexture;this._blitRenderer.render(e,l,9728,i),e.setViewport(s.x,s.y,s.width,s.height),this._boundFBO=null}},e.prototype.needsRedraw=function(){return this._fadeRecorder.needsRedraw()},e.prototype.hitTest=function(e,t,i,n,r,a,o){var s=[0,0],l=[0,0],d=e.state;d.toMap(s,[0,0]),d.toMap(l,[a,a]);var u=n.filter(function(e){return!(s[0]>e.bounds[2]||l[0]<e.bounds[0]||s[1]<e.bounds[3]||l[1]>e.bounds[1])});if(0===u.length)return[];u.sort(function(e,t){return e.key.level-t.key.level});for(var c=u.length,f=1;f<=c;f++){(x=u[f-1]).attached&&(x.stencilData.reference=f,x.stencilData.mask=255)}o(d,r,u);var h=e.context;this._hittestFBO||(this._hittestFBO=m.create(h,{colorTarget:0,depthStencilTarget:3,width:a,height:a}));var _=h.getViewport(),p=h.getBoundFramebufferObject();h.bindFramebuffer(this._hittestFBO),h.setViewport(0,0,a,a);var v=h.gl;h.setDepthWriteEnabled(!0),h.setStencilWriteMask(255),h.setClearColor(1,1,1,1),h.setClearDepth(1),h.setClearStencil(0),h.clear(v.COLOR_BUFFER_BIT|v.DEPTH_BUFFER_BIT|v.STENCIL_BUFFER_BIT),h.setDepthWriteEnabled(!1),this.drawClippingMasks(h,u),h.setBlendingEnabled(!1),h.setStencilWriteMask(0),h.setStencilOp(7680,7680,7681),h.setDepthFunction(515),h.setDepthTestEnabled(!0),h.setDepthWriteEnabled(!0),h.setStencilTestEnabled(!0);for(var g=0;g<c;g++){var x;(x=u[g]).attached&&x.doRender(e)}h.setStencilTestEnabled(!1),h.setDepthTestEnabled(!1),this._readbackBuffer||(this._readbackBuffer=new Uint8Array(4*a*a),this._readbackBuffer32=new Uint32Array(this._readbackBuffer.buffer)),this._hittestFBO.readPixels(0,0,a,a,6408,5121,this._readbackBuffer);var y=new Set,b=a*a,w=Math.round(b/2),D=this._readbackBuffer32[w];4294967295!==D&&y.add(D);for(f=0;f<b;f++)4294967295!==(D=this._readbackBuffer32[f])&&y.add(D);h.bindFramebuffer(p),h.setViewport(_.x,_.y,_.width,_.height);var T=[];return y.forEach(function(e){T.push(e)}),T},e.prototype._renderBackground=function(e,t,i,n,r,a,o){this._backgroundRenderer.render(e,t,i,n,r,a,this._SpriteMosaic,this._SpriteMosaic.pixelRatio,o)},e.prototype._renderLine=function(e,t,i,n,r,a,o){this._lineRenderer.render(e,t,i,n,this._state,r,a,this._SpriteMosaic,this._extrudeMatrix,this._SpriteMosaic.pixelRatio,o)},e.prototype._renderFill=function(e,t,i,n,r,a,o){this._fillRenderer.render(e,t,i,this._state.rotation,n,r,a,this._SpriteMosaic,this._extrudeMatrix,this._SpriteMosaic.pixelRatio,o)},e.prototype._renderCircle=function(e,t,i,n,r,a,o,s){var l=!0;r===a.key.level&&(l=!1),e.setStencilTestEnabled(l),this._circleRenderer.render(e,t,i,n,this._state.rotation,a,o,this._extrudeMatrix,s)},e.prototype._renderSymbol=function(e,t,i,n,r,a,o,s){var l=!0;r===a.key.level&&(l=!1),e.setStencilTestEnabled(l),this._symbolRenderer.render(e,t,i,n,this._state.rotation,this._fadeRecorder.getFadeValues(this._ignoreSpeed),a,o,this._SpriteMosaic,this._glyphMosaic,this._extrudeMatrix,this._extrudeNoRotationMatrix,this._SpriteMosaic.pixelRatio,s)},e}()}.apply(null,n))||(e.exports=r)},"66Fz":function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("2ZMW")],void 0===(r=function(e,t,i){return function(){function e(e,t){this._width=0,this._height=0,this._free=[],this._width=e,this._height=t,this._free.push(new i(0,0,e,t))}return Object.defineProperty(e.prototype,"width",{get:function(){return this._width},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"height",{get:function(){return this._height},enumerable:!0,configurable:!0}),e.prototype.allocate=function(e,t){if(e>this._width||t>this._height)return new i;for(var n=null,r=-1,a=0;a<this._free.length;++a){var o=this._free[a];e<=o.width&&t<=o.height&&(null===n||o.y<=n.y&&o.x<=n.x)&&(n=o,r=a)}return null===n?new i:(this._free.splice(r,1),n.width<n.height?(n.width>e&&this._free.push(new i(n.x+e,n.y,n.width-e,t)),n.height>t&&this._free.push(new i(n.x,n.y+t,n.width,n.height-t))):(n.width>e&&this._free.push(new i(n.x+e,n.y,n.width-e,n.height)),n.height>t&&this._free.push(new i(n.x,n.y+t,e,n.height-t))),new i(n.x,n.y,e,t))},e.prototype.release=function(e){for(var t=0;t<this._free.length;++t){var i=this._free[t];if(i.y===e.y&&i.height===e.height&&i.x+i.width===e.x)i.width+=e.width;else if(i.x===e.x&&i.width===e.width&&i.y+i.height===e.y)i.height+=e.height;else if(e.y===i.y&&e.height===i.height&&e.x+e.width===i.x)i.x=e.x,i.width+=e.width;else{if(e.x!==i.x||e.width!==i.width||e.y+e.height!==i.y)continue;i.y=e.y,i.height+=e.height}this._free.splice(t,1),this.release(e)}this._free.push(e)},e}()}.apply(null,n))||(e.exports=r)},"7ha9":function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("FXVB"),i("oZZu"),i("ab6c"),i("vlC2"),i("j2SP"),i("BEeJ"),i("lr+P"),i("z2+Q")],void 0===(r=function(e,t,i,n,r,a,o,s,l,d){return function(){function e(e){this._viewProjMat=n.mat4f32.create(),this._offsetVector=a.vec3f32.create(),this._spritesTextureSize=r.vec2f32.create(),this._color=o.vec4f32.create(),this._initialized=!1,this._programOptions={id:!1,dd:!1,sdf:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,n,r,a,o,d,u,c,f,h,_){var p=this;this._initialized||this._initialize(e);var m=u.hasDataDrivenIconSize?1:u.getLayoutValue("icon-size",n),v=u.hasDataDrivenIconColor?[1,1,1,1]:u.getPaintValue("icon-color",n),g=u.hasDataDrivenIconOpacity?1:u.getPaintValue("icon-opacity",n),x=v[3]*g*_;this._color[0]=x*v[0],this._color[1]=x*v[1],this._color[2]=x*v[2],this._color[3]=x;var y=u.getLayoutValue("icon-rotation-alignment",n);2===y&&(y=1===u.getLayoutValue("symbol-placement",n)?0:1);var b=0===y,w=t.isSDF,D=u.hasDataDrivenIcon,T=3===r,V=s.degToByte(a),A=d.tileTransform.transform,S=u.getPaintValue("icon-translate",n);if(0!==S[0]||0!==S[1]){i.mat4.copy(this._viewProjMat,d.tileTransform.transform);var I=S[0],z=S[1],M=0,C=0,E=d.coordRange/512,R=(1<<d.key.level)/Math.pow(2,n)*E;if(1===u.getPaintValue("icon-translate-anchor",n)){var O=-s.C_DEG_TO_RAD*a,P=Math.sin(O),F=Math.cos(O);M=R*(I*F-z*P),C=R*(I*P+z*F)}else M=R*I,C=R*z;this._offsetVector[0]=M,this._offsetVector[1]=C,this._offsetVector[2]=0,i.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),A=this._viewProjMat}var k=b?f:h,B=this._getIconVAO(e,d,D);if(B){e.bindVAO(B);var U=(T?1:0)<<2|(D?1:0)<<1|(w?1:0),L=this._programOptions;L.id=T,L.dd=D,L.sdf=w;var N=this._programCache.getProgram(4,U,L);if(e.bindProgram(N),w){var j=u.getPaintValue("icon-halo-color",n),H=u.getPaintValue("icon-halo-width",n);N.setUniform4f("u_outlineColor",j[0],j[1],j[2],j[3]),N.setUniform1f("u_outlineSize",H)}if(N.setUniformMatrix4fv("u_transformMatrix",A),N.setUniformMatrix4fv("u_extrudeMatrix",k),N.setUniform2fv("u_normalized_origin",d.tileTransform.displayCoord),N.setUniform1f("u_depth",u.z),N.setUniform1f("u_mapRotation",V),N.setUniform1f("u_keepUpright",0),N.setUniform1f("u_level",10*n),N.setUniform1f("u_fadeSpeed",10*o.fadeSpeed),N.setUniform1f("u_minfadeLevel",10*o.minfadeLevel),N.setUniform1f("u_maxfadeLevel",10*o.maxfadeLevel),N.setUniform1f("u_fadeChange",10*(n+o.fadeChange)),N.setUniform1i("u_texture",5),N.setUniform1f("u_size",m),N.setUniform4fv("u_color",this._color),T){var W=l.int32To4Bytes(t.layerID);N.setUniform4f("u_id",W[0],W[1],W[2],W[3])}t.markerPerPageElementsMap.forEach(function(t,i){p._spritesTextureSize[0]=c.getWidth(i)/4,p._spritesTextureSize[1]=c.getHeight(i)/4,N.setUniform2fv("u_mosaicSize",p._spritesTextureSize),c.bind(e,9729,i,5),e.drawElements(4,t[1],5125,12*t[0])}),e.bindVAO()}},e.prototype._initialize=function(e){return!!this._initialized||(this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:16,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:16,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:16,normalized:!1,divisor:0}]},this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:24,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:24,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:24,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:24,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:16,stride:24,normalized:!0,divisor:0},{name:"a_size",count:1,type:5126,offset:20,stride:24,normalized:!1,divisor:0}]},this._initialized=!0,!0)},e.prototype._getIconVAO=function(e,t,i){if(i){if(t.iconDDVertexArrayObject)return t.iconDDVertexArrayObject;var n=t.iconDDVertexBuffer,r=t.iconIndexBuffer;return n&&r?(t.iconDDVertexArrayObject=new d(e,this._programCache.getProgramAttributes(4),this._vertexAttributesDD,{geometry:n},r),t.iconDDVertexArrayObject):null}if(t.iconVertexArrayObject)return t.iconVertexArrayObject;n=t.iconVertexBuffer,r=t.iconIndexBuffer;return n&&r?(t.iconVertexArrayObject=new d(e,this._programCache.getProgramAttributes(4),this._vertexAttributes,{geometry:n},r),t.iconVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},ADZV:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("qMld")],void 0===(r=function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0}),t.when=function e(t,n){return Array.isArray(n)?i.create(function(e){t(n,function(){for(var t=[],i=0;i<arguments.length;i++)t[i]=arguments[i];e(t)})}):e(t,[n]).then(function(e){return e[0]})},t.getAbsMid=function(e,t,i){return t.toAbsMid?t.toAbsMid(e):i.id.replace(/\/[^\/]*$/gi,"/")+e}}.apply(null,n))||(e.exports=r)},Ak4l:function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){return{background:{"background.frag":"#ifdef PATTERN\nuniform lowp float u_opacity;\nuniform mediump vec2 u_pattern_tl;\nuniform mediump vec2 u_pattern_br;\nuniform sampler2D u_texture;\n\nvarying mediump vec2 v_tileTextureCoord;\n#else\nuniform lowp vec4 u_color;\n#endif // PATTERN\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvoid main() {\n#ifdef PATTERN\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\n  mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\n\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\n  // we need to only sample from area that has our sprite in the mosaic.\n  mediump vec2 samplePos = mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\n\n  // sample the sprite mosaic\n  lowp vec4 color = texture2D(u_texture, samplePos);\n  gl_FragColor = u_opacity * color;\n#else\n  gl_FragColor = u_color;\n#endif // PATTERN\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","background.vert":"precision mediump float;\n\nattribute vec2 a_pos;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\nuniform highp mat4 u_transformMatrix;\nuniform mediump vec2 u_normalized_origin;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix; // can we use medium precision?\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\nvoid main() {\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(u_coord_range * a_pos, 0.0, 1.0);\n\n#ifdef PATTERN\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from tile coordinates\n  v_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\n#endif // PATTERN\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n}\n"},circle:{"circle.frag":"precision lowp float;\n\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  mediump float dist = length(v_offset);\n\n  mediump float alpha = smoothstep(0.0, -v_blur, dist - 1.0);\n\n  lowp float color_mix_ratio = v_stroke_width < 0.01 ? 0.0 : smoothstep(-v_blur, 0.0, dist - v_radius / (v_radius + v_stroke_width));\n\n  gl_FragColor = alpha * mix(v_color, v_stroke_color, color_mix_ratio);\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","circle.vert":"precision mediump float;\n\nattribute vec2 a_pos;\nattribute vec4 a_color;\nattribute vec4 a_stroke_color;\nattribute vec4 a_data;\n\nconst float sizePrecision = 0.25; // 1/4\nconst float blurPrecision = 0.03125; // 1/32\n\nvarying lowp vec4 v_color;\nvarying lowp vec4 v_stroke_color;\nvarying mediump float v_blur;\nvarying mediump float v_stroke_width;\nvarying mediump float v_radius;\nvarying mediump vec2 v_offset;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n\n// the z of the layer. Given by the order of the layers in the style\nuniform mediump float u_depth;\n\n// the opacity of the layer given by the painter\nuniform mediump float u_radius;\nuniform lowp vec4 u_color;\nuniform mediump float u_blur;\nuniform mediump float u_stroke_width;\nuniform lowp vec4 u_stroke_color;\n\nuniform mediump float u_antialiasingWidth; // antialiasing (factors in the pixel_ratio for high res devices)\n\nvoid main()\n{\n  v_color = a_color * u_color;\n  v_stroke_color = a_stroke_color * u_stroke_color;\n  v_stroke_width = a_data[1] * sizePrecision * u_stroke_width;\n  v_radius = a_data[2] * u_radius;\n  v_blur = max(a_data[0] * blurPrecision + u_blur, u_antialiasingWidth / (v_radius + v_stroke_width));\n\n  mediump vec2 offset = vec2(mod(a_pos, 2.0) * 2.0 - 1.0);\n  v_offset = offset;\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos * 0.5, 0.0, 1.0) + u_extrudeMatrix * (v_radius + v_stroke_width) * vec4(offset, 0.0, 0.0);\n}\n"},fill:{"fill.frag":"precision lowp float;\n\n#ifdef PATTERN\nuniform mediump vec2 u_pattern_tl;\nuniform mediump vec2 u_pattern_br;\nuniform lowp sampler2D u_texture;\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvarying lowp vec4 v_color;\n\nvec4 mixColors(vec4 color1, vec4 color2) {\n  // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending)\n  // we use pre-multiplied colors hence the need for this kind of mixing. At lease we save ourselves an extra division...\n  float compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\n  vec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\n\n  return vec4(compositeColor, compositeAlpha);\n}\n\nvoid main()\n{\n#ifdef PATTERN\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\n  mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\n\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\n  // we need to only sample from area that has our sprite in the mosaic.\n  mediump vec2 samplePos = mix(u_pattern_tl, u_pattern_br, normalizedTextureCoord);\n\n  // sample the sprite mosaic\n  lowp vec4 color = texture2D(u_texture, samplePos);\n  gl_FragColor = v_color[3] * color;\n#else\n  gl_FragColor = v_color;\n#endif // PATTERN\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","fill.vert":"precision mediump float;\n\nattribute vec2 a_pos;\n\nuniform highp mat4 u_transformMatrix;\nuniform highp vec2 u_normalized_origin;\nuniform mediump float u_depth;\n\n#ifdef PATTERN\nuniform mediump mat3 u_pattern_matrix;\nvarying mediump vec2 v_tileTextureCoord;\n#endif // PATTERN\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\n#ifdef DD\nattribute vec4 a_color;\n#endif // DD\nuniform lowp vec4 u_color;\nvarying lowp vec4 v_color;\n\nvoid main()\n{\n#ifdef DD\n  v_color = a_color * u_color;\n#else\n  v_color = u_color;\n#endif // DD\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n#ifdef PATTERN\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from tile coordinates\n  // (-4k to 8k -1) to texture coordinates.\n  v_tileTextureCoord = (u_pattern_matrix * vec3(a_pos, 1.0)).xy;\n#endif // PATTERN\n\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0, 1.0);\n}\n"},icon:{"icon.frag":"precision mediump float;\n\nuniform lowp sampler2D u_texture; // SDF texture\n#ifdef SDF\nuniform lowp vec4 u_color; // a color to override the one of the vertex\nuniform lowp vec4 u_outlineColor;\nuniform mediump float u_outlineSize;\n#endif // SDF\n\nvarying mediump vec2 v_tex;\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n\nvarying mediump vec2 v_size;\n\nvarying lowp vec4 v_color;\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\n// we need the conversion function from RGBA to float\n#include <util/encoding.glsl>\n\nvec4 mixColors(vec4 color1, vec4 color2) {\n  // perform un-premultiplied over operator (see https://en.wikipedia.org/wiki/Alpha_compositing#Alpha_blending)\n  // we use pre-multiplied colors hence the need for this kind of mixing. At lease we save ourselves an extra division...\n  float compositeAlpha = color2.a + color1.a * (1.0 - color2.a);\n  vec3 compositeColor = color2.rgb + color1.rgb * (1.0 - color2.a);\n\n  return vec4(compositeColor, compositeAlpha);\n}\n\nvoid main()\n{\n#ifdef SDF\n  lowp vec4 fillPixelColor = v_color;\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  float d = rgba2float(texture2D(u_texture, v_tex)) - 0.5;\n\n  // the soft edge ratio is about 1.5 pixels allocated for the soft edge.\n  // 1 / 86 represents a single pixel given the size of the SDF is 128 and we add 4 pixels margins to deal with\n  // other non SDF types.\n  // The rasterized geometry takes only 86 pixels because of the extra 16 pixels margin for the outline.\n  const float sofetEdgeRatio = 0.248062016; // ==> (32.0 / 86.0) / 1.5;\n  float size = max(v_size.x, v_size.y);\n  float dist = d * sofetEdgeRatio * size;\n\n  // set the fragment's transparency according to the distance from the edge\n  fillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\n\n  // count for the outline\n  // therefore tint the entire icon area.\n  if (u_outlineSize > 0.25) {\n    lowp vec4 outlinePixelColor = u_outlineColor;\n    // the outline limit ratio is derived from the 16 pixels allocated for the outline and the fact that 1/86 represents\n    // a single pixel.\n    const float outlineLimitRatio = (16.0 / 86.0);\n    float clampedOutlineSize = sofetEdgeRatio * min(u_outlineSize, outlineLimitRatio * max(v_size.x, v_size.y));\n\n    outlinePixelColor *= clamp(0.5 - (abs(dist) - clampedOutlineSize), 0.0, 1.0);\n\n    // finally combine the outline and the fill colors\n    gl_FragColor = v_transparency * mixColors(fillPixelColor, outlinePixelColor);\n  }\n  else {\n    gl_FragColor = v_transparency * fillPixelColor;\n  }\n#else // not an SDF\n  lowp vec4 texColor = texture2D(u_texture, v_tex);\n  gl_FragColor = v_transparency * texColor;\n#endif // SDF\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","icon.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_tex;\nattribute vec4 a_levelInfo;\n\n#ifdef DD\nattribute vec4 a_color;\nattribute mediump float a_size;\n#endif // DD\nuniform lowp vec4 u_color;\nuniform mediump float u_size;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\nvarying lowp vec4 v_color;\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n\n// the size of the mosaic given in pixels\nuniform vec2 u_mosaicSize;\n\n// the z of the layer. Given by the order of the layers in the style\nuniform mediump float u_depth;\n\n// the map's rotation from the north\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\n\n// indicate whether the current set of iconst should be kept upright when the map is rotated\nuniform lowp float u_keepUpright;\n\n// the rate of the change in the opacity (fade) of the icons\nuniform mediump float u_fadeSpeed;\n\n// the low level we transition (to/from)\nuniform mediump float u_minfadeLevel;\n\n// the high level we transition (to/from)\nuniform mediump float u_maxfadeLevel;\n\n// the amount of fade given teh current time past the last recorded level\nuniform mediump float u_fadeChange;\n\n// the opacity of the layer given by the painter\nuniform mediump float u_opacity;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying mediump vec2 v_tex;\n\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n\nvarying mediump vec2 v_size;\n\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precision we multiply the values\n// by 8 and then at the shader devide by the same number\nconst float C_OFFSET_PRECISION = 1.0 / 8.0;\n\nconst float C_256_TO_RAD = 3.14159265359 / 128.0;\nconst float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float tileCoordRatio = 1.0 / 8.0;\n\nvoid main()\n{\n  mediump float a_labelMinLevel = a_levelInfo[0];\n  mediump float a_angle         = a_levelInfo[1];\n  mediump float a_minLevel      = a_levelInfo[2];\n  mediump float a_maxLevel      = a_levelInfo[3];\n\n  // if the given vertex should not be visible simply clip it by adding it a value that will push it outside the clipping plane\n  mediump float delta_z = 0.0;\n\n  // If the label rotates with the map, and if the rotated label is upside down, hide it\n  mediump float rotated = mod(a_angle + u_mapRotation, 256.0);\n  delta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated)); //ie. z += (flip > 0) && (64 <= rotated) && (rotated < 192)\n\n  // u_level is the current service level adjusted for the change in font size\n  delta_z += 1.0 - step(a_minLevel, u_level); // Test if (level < minLevel)\n  delta_z += step(a_maxLevel, u_level); // Test if (maxLevel <= level)\n\n  // calculate the alpha given the change in the fade and the fade-speed\n  lowp float alpha = clamp((u_fadeChange - a_labelMinLevel) / u_fadeSpeed, 0.0, 1.0);\n\n  // if the speed is positive we are zooming in and therefore we need to 'fade-in'. Else we need to 'fade-out'\n  v_transparency = (u_fadeSpeed >= 0.0 ? alpha : 1.0 - alpha);\n\n  // now deal with the min/max fade-levels. If we exceeded the level we simply snap to 0 or 1\n  if (u_maxfadeLevel < a_labelMinLevel)\n  {\n    v_transparency = 0.0;\n  }\n  if (u_minfadeLevel >= a_labelMinLevel)\n  {\n    v_transparency = 1.0;\n  }\n\n  // if label had been faded out, clip it\n  delta_z += step(v_transparency, 0.0);\n\n  vec2 offset = C_OFFSET_PRECISION * a_vertexOffset;\n\n  v_size = abs(offset);\n\n#ifdef SDF\n  offset = (120.0 / 86.0) * offset;\n#endif // SDF\n\n#ifdef DD\n  mediump float icon_size = a_size * u_size;\n#else\n  mediump float icon_size = u_size;\n#endif // DD\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * icon_size * vec4(offset, delta_z, 0.0);\n\n#ifdef DD\n  v_color = a_color * u_color;\n#else\n  v_color = u_color;\n#endif // DD\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n  v_tex = a_tex.xy / u_mosaicSize;\n  v_transparency *= v_color.w;\n}\n"},line:{"line.frag":"varying mediump vec2 v_normal;\nvarying highp float v_accumulatedDistance;\n\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\n\nvarying mediump float v_blur;\n\n#ifdef PATTERN\nuniform mediump vec2 u_pattern_tl;\nuniform mediump vec2 u_pattern_br;\nuniform mediump vec2 u_spriteSize;\nuniform sampler2D u_texture;\n\n// Horizontal scale is used to scale the horizontal texture coordinate v_normal.x before adding it as an offset to the\n// accumulated distance. Most vertices will have v_normal.x == 0, because the pattern must be sampled only depending on\n// the v_accumulatedDistance value. But tessellation at caps can have vertices with v_normal.x != 0, thus allowing to\n// \"keep moving\" for a few more pixel even when the line has ended or has not started yet.\nconst mediump float tileCoordRatio = 8.0;\n#else\nvarying mediump vec2 v_dasharray;\n#endif\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\n  mediump float fragDist = length(v_normal) * v_lineHalfWidth;\n\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\n  // We need to count for both sides of the line.\n  lowp float alpha = clamp((v_lineHalfWidth - fragDist) / v_blur, 0.0, 1.0);\n\n#ifdef PATTERN\n  // we need to calculate the relative portion of the line texture along the line given the accumulated distance aliong the line\n  // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\n  mediump float relativeTexX = mod((v_accumulatedDistance + v_normal.x * v_lineHalfWidth * tileCoordRatio) / u_spriteSize.x, 1.0);\n\n  // in order to calculate the texture coordinates perpendicular to the line (Y axis), we use the interpolated normal values\n  // which range from -1.0 to 1.0. On the line's centerline, the value of the interpolated normal is 0.0, however the relative\n  // texture value should be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\n  // (TL) ---------------------------      --\x3e left edge of line. Interpolated normal is 1.0\n  //              | -> line-width / 2\n  //      - - - - - - - - - - - - - -\n  //              | -> line-width / 2\n  //      ---------------------------- (BR)--\x3e right edge of line. Interpolated normal is -1.0\n\n  mediump float relativeTexY = 0.5 + (v_normal.y * v_lineHalfWidth / u_spriteSize.y);\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(u_pattern_tl, u_pattern_br, vec2(relativeTexX, relativeTexY));\n\n  // get the color from the texture\n  lowp vec4 color = texture2D(u_texture, texCoord);\n\n  // finally write the fragment value\n  gl_FragColor = alpha * v_color[3] * color;\n#else\n  // now calculate the dashes given the accumulated distance of the line:\n  // start with calculating a normalized position along the line\n  lowp float dashPos =  mod(v_accumulatedDistance, v_dasharray.x + v_dasharray.y);\n\n  // calculate the contribution to the alpha of the dash part. It is provided by the shortest portion of the position along the dash.\n  // we must clamp since the value might be bigger than 1 or smaller than zero (when over a dash).\n  //   | <--- pos along the dash part\n  // -------_______-------_______\n  // when the dashPos is over the 'gap' part of the dash dasharray.x - dashPos is negative and therefore the alpha will\n  // get clamped to zero.\n  // when dasharray.x - dashPos is positive, or when dashPos is smaller than 1.0, it gives us a soft edge to each dash part.\n  // along the direction of the line.\n  lowp float dashAlpha = clamp(min(dashPos, v_dasharray.x - dashPos) + 0.5, 0.0, 1.0);\n\n  // if we don't have a no-data part to the dash then it is a solid line\n  dashAlpha = max(sign(-v_dasharray.y), dashAlpha);\n  // finally multiply the fragment's alpha by the calculated dash-alpha\n  alpha *= dashAlpha;\n\n  // output the fragment color\n  gl_FragColor = alpha * v_color;\n#endif // PATTERN\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","line.vert":"/* The implementation of the renderer is based on the article and implementation of MB described here:\n* https://www.mapbox.com/blog/drawing-antialiased-lines/\n*/\n\nattribute vec2 a_pos;\nattribute vec4 a_offsetAndNormal;\nattribute vec2 a_accumulatedDistance;\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n\nuniform mediump float u_blur;\nuniform mediump float u_antialiasing; // the feather distance at which the line edge fades out\n\n// the z of the layer. Given by the order of the layers in the style\nuniform mediump float u_depth;\n\n// the interpolated normal to the line. the information is packed into the two LSBs of the vertex coordinate\nvarying mediump vec2 v_normal;\n\n// the accumulated distance along the line. We need this information in order to render the dashes.\nvarying highp float v_accumulatedDistance;\n\nconst float scale = 1.0 / 31.0;\n\n#ifdef DD\nattribute vec4 a_color;\nattribute mediump float a_width;\n#endif // DD\nuniform lowp vec4 u_color;\nuniform mediump float u_width;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\nvarying lowp vec4 v_color;\nvarying mediump float v_lineHalfWidth; // the inset and outset of the line\nvarying mediump float v_blur;\n\n#ifndef PATTERN\nuniform mediump vec2 u_dasharray;\nvarying mediump vec2 v_dasharray;\n#endif\n\nvoid main()\n{\n  v_normal = a_offsetAndNormal.zw * scale;\n\n#ifdef DD\n  v_lineHalfWidth = a_width * u_width;\n#else\n  v_lineHalfWidth = u_width;\n#endif // DD\n\n  v_lineHalfWidth += u_antialiasing;\n  v_lineHalfWidth *= 0.5;\n\n#ifndef PATTERN\n#ifdef DD\n  v_dasharray = u_dasharray * a_width;\n#else\n  v_dasharray = u_dasharray * u_width;\n#endif // DD\n#endif\n\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\n  // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\n  mediump vec2 dist = v_lineHalfWidth * a_offsetAndNormal.xy * scale;\n\n  // transform the vertex\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * vec4(dist, 0.0, 0.0);\n\n  // the accumulated distance will be used to calculate the dashes (or the no-data...)\n  v_accumulatedDistance = a_accumulatedDistance.x;\n\n  v_blur = u_blur + u_antialiasing;\n\n  #ifdef DD\n    v_color = a_color * u_color;\n  #else\n    v_color = u_color;\n  #endif // DD\n\n  #ifdef ID\n    v_id = u_id / 255.0;\n  #endif // ID\n}\n"},outline:{"outline.frag":"varying lowp vec4 v_color;\nvarying mediump vec2 v_normal;\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  // Calculate the distance of the pixel from the line in pixels.\n  lowp float dist = abs(v_normal.y);\n\n  lowp float alpha = smoothstep(1.0, 0.0, dist);\n  gl_FragColor = alpha * v_color;\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","outline.vert":"attribute vec2 a_pos;\nattribute vec2 a_offset;\nattribute vec2 a_xnormal;\n\n#ifdef DD\nattribute vec4 a_color;\n#endif // DD\nuniform lowp vec4 u_color;\nvarying lowp vec4 v_color;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\nuniform highp mat4 u_transformMatrix;\nuniform highp mat4 u_extrudeMatrix;\nuniform highp vec2 u_normalized_origin;\nuniform mediump float u_depth;\nuniform mediump float u_outline_width;\n\nvarying lowp vec2 v_normal;\n\nconst float scale = 1.0 / 15.0;\n\nvoid main()\n{\n#ifdef DD\n  v_color = a_color * u_color;\n#else\n  v_color = u_color;\n#endif // DD\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n  v_normal = a_xnormal;\n\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is given in integers (for the\n  // sake of using less attribute memory, we need to scale it back to the original range of ~ 0: 1)\n  mediump vec4 dist = vec4(u_outline_width * a_offset * scale, 0.0, 0.0);\n\n  // Remove the texture normal bit of the position before scaling it with the\n  // model/view matrix. Add the extrusion vector *after* the model/view matrix\n  // because we're extruding the line in pixel space, regardless of the current\n  // tile's zoom level.\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * dist;\n}\n"},text:{"text.frag":"uniform lowp sampler2D u_texture;\nuniform mediump float u_edgeDistance;\n\nvarying lowp vec2 v_tex;\nvarying lowp float v_transparency;\nvarying lowp vec4 v_color;\nvarying mediump float v_edgeWidth;\nvarying mediump float v_edgeDistance;\n\n#ifdef ID\nvarying mediump vec4 v_id;\n#endif // ID\n\n// this is taken from http://www.valvesoftware.com/publications/2007/SIGGRAPH2007_AlphaTestedMagnification.pdf\n// and https://www.mapbox.com/blog/text-signed-distance-fields/\n// http://metalbyexample.com/rendering-text-in-metal-with-signed-distance-fields/\n\nvoid main()\n{\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  mediump float alpha = smoothstep(v_edgeDistance - v_edgeWidth, v_edgeDistance + v_edgeWidth, dist) * v_transparency;\n\n  gl_FragColor = alpha * v_color;\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","text.vert":"attribute vec2 a_pos;\nattribute vec2 a_vertexOffset;\nattribute vec4 a_tex;\nattribute vec4 a_levelInfo;\n\nuniform lowp vec4 u_color; // always defined as halo does not support data driven but text does\n#ifdef DD\nattribute vec4 a_color;\n#endif // DD\nvarying lowp vec4 v_color;\n\nuniform mediump float u_size;\n#ifdef DD\nattribute mediump float a_size;\n#endif // DD\nvarying mediump float v_size;\n\n#ifdef ID\nuniform mediump vec4 u_id;\nvarying mediump vec4 v_id;\n#endif // ID\n\n\n// attribute bool a_visible; // --\x3e a one bit controlling the visibility of the vertex\n\n// the relative transformation of a vertex given in tile coordinates to a relative normalized coordinate\n// relative to the tile's upper left corner\n// the extrusion vector.\nuniform highp mat4 u_transformMatrix;\n\n// the extrude matrix which is responsible for the 'anti-zoom' as well as the rotation\nuniform highp mat4 u_extrudeMatrix;\n\n// u_normalized_origin is the tile's upper left corner given in normalized coordinates\nuniform highp vec2 u_normalized_origin;\n\n// the size of the mosaic given in pixels\nuniform vec2 u_mosaicSize;\n\n// the z of the layer. Given by the order of the layers in the style\nuniform mediump float u_depth;\n\n// the map's rotation from the north\nuniform mediump float u_mapRotation;\nuniform mediump float u_level;\n\n// indicate whether the current set of iconst should be kept upright when the map is rotated\nuniform lowp float u_keepUpright;\n\n// the rate of the change in the opacity (fade) of the icons\nuniform mediump float u_fadeSpeed;\n\n// the low level we transition (to/from)\nuniform mediump float u_minfadeLevel;\n\n// the high level we transition (to/from)\nuniform mediump float u_maxfadeLevel;\n\n// the amount of fade given teh current time past the last recorded level\nuniform mediump float u_fadeChange;\n\n// the opacity of the layer given by the painter\nuniform mediump float u_opacity;\n\n// the interpolated texture coordinate value to be used by the fragment shader in order to sample the sprite texture\nvarying lowp vec2 v_tex;\n\n// the calculated transparency to be applied by the fragment shader. It is incorporating both the fade as well as the\n// opacity of the layer given by the painter\nvarying lowp float v_transparency;\n\n// the vertex offsets are given in integers, therefore in order to maintain a reasonable precision we multiply the values\n// by 8 and then at the shader divide by the same number\nconst float offsetPrecision = 1.0 / 8.0;\n\n// outline position and appearance\nconst mediump float edgePos = 0.75; // defined by the SDF encoding\nuniform mediump float u_edgeDistance;\nuniform mediump float u_edgeBlur;\nuniform mediump float u_antialiasingWidth; // antialiasing (factors in the pixel_ratio for high res devices)\n\nvarying mediump float v_edgeDistance; // will factor in the size\nvarying mediump float v_edgeWidth; // will factor in the size\n\nuniform lowp float u_halo; // needed to avoid using the color attribute for halo\n\nvoid main()\n{\n  mediump float a_labelMinLevel = a_levelInfo[0];\n  mediump float a_angle        = a_levelInfo[1];\n  mediump float a_minLevel    = a_levelInfo[2];\n  mediump float a_maxLevel    = a_levelInfo[3];\n\n  // if the given vertex should not be visible simply clip it by adding it a value that will push it outside the clipping plane\n  mediump float delta_z = 0.0;\n\n  // TODO: force clipping the vertex in case that the vertex isn't visible\n  //delta_z += a_visible ? 0.0 : 1.0;\n\n  // If the label rotates with the map, and if the rotated label is upside down, hide it\n  mediump float rotated = mod(a_angle + u_mapRotation, 256.0);\n  delta_z += (1.0 - step(u_keepUpright, 0.0)) * step(64.0, rotated) * (1.0 - step(192.0, rotated)); //ie. z += (flip > 0) && (64 <= rotated) && (rotated < 192)\n\n  // u_level is the current service level adjusted for the change in font size\n  delta_z += 1.0 - step(a_minLevel, u_level); // Test if (level < minLevel)\n  delta_z += step(a_maxLevel, u_level); // Test if (maxLevel <= level)\n\n  // calculate the alpha given the change in the fade and the fade-speed\n  lowp float alpha = clamp((u_fadeChange - a_labelMinLevel) / u_fadeSpeed, 0.0, 1.0);\n\n  // if the speed is positive we are zooming in and therefore we need to 'fade-in'. Else we need to 'fade-out'\n  v_transparency = (u_fadeSpeed >= 0.0 ? alpha : 1.0 - alpha);\n\n  // now deal with the min/max fade-levels. If we exceeded the level we simply snap to 0 or 1\n  if (u_maxfadeLevel < a_labelMinLevel)\n  {\n    v_transparency = 0.0;\n  }\n  if (u_minfadeLevel >= a_labelMinLevel)\n  {\n    v_transparency = 1.0;\n  }\n\n  // if label has been faded out, clip it\n  delta_z += step(v_transparency, 0.0);\n\n  v_tex = a_tex.xy / u_mosaicSize;\n\n#ifdef DD\n  if (u_halo > 0.5)\n  {\n    v_color = u_color;\n  }\n  else\n  {\n    v_color = a_color * u_color;\n    // opacity already factored in a_color\n  }\n#else\n  v_color = u_color;\n#endif // DD\n\n#ifdef DD\n  v_size = a_size * u_size;\n#else\n  v_size = u_size;\n#endif // DD\n\n#ifdef ID\n  v_id = u_id / 255.0;\n#endif // ID\n\n  v_edgeDistance = edgePos - u_edgeDistance / v_size;\n  v_edgeWidth = (u_antialiasingWidth + u_edgeBlur) / v_size;\n\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(a_pos, 0.0, 1.0) + u_extrudeMatrix * v_size * vec4(offsetPrecision * a_vertexOffset, delta_z, 0.0);\n}\n"},tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\nvarying mediump vec2 v_tex;\n\nvoid main(void) {\n  lowp vec4 color = texture2D(u_texture, v_tex);\n  gl_FragColor = 0.75 * color;\n}\n","tileInfo.vert":"attribute vec2 a_pos;\n\nuniform highp mat4 u_transformMatrix;\nuniform mediump vec2 u_normalized_origin;\nuniform mediump float u_depth;\nuniform mediump float u_coord_ratio;\nuniform mediump vec2 u_delta; // in tile coordinates\nuniform mediump vec2 u_dimensions; // in tile coordinates\n\nvarying mediump vec2 v_tex;\n\nvoid main() {\n  mediump vec2 offests = u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\n  gl_Position = vec4(u_normalized_origin, u_depth, 0.0) + u_transformMatrix * vec4(offests, 0.0, 1.0);\n\n  v_tex = a_pos;\n}\n"},util:{"encoding.glsl":"// Factors to convert rgba back to float\nconst vec4 rgba2float_factors = vec4(\n    255.0 / (256.0),\n    255.0 / (256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n  );\n\nfloat rgba2float(vec4 rgba) {\n  // Convert components from 0->1 back to 0->255 and then\n  // add the components together with their corresponding\n  // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n  return dot(rgba, rgba2float_factors);\n}\n"}}}.apply(null,n))||(e.exports=r)},AvrD:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("xhoE"),i("SyoC"),i("oZZu"),i("ab6c"),i("nrlZ"),i("Brhx"),i("f3JK"),i("3JFk"),i("QFi0")],void 0===(r=function(e,t,i,n,r,a,o,s,l,d,u){var c=["fillVertexBuffer","fillDDVertexBuffer","fillIndexBuffer","outlineVertexBuffer","outlineDDVertexBuffer","outlineIndexBuffer","lineVertexBuffer","lineDDVertexBuffer","lineIndexBuffer","iconVertexBuffer","iconDDVertexBuffer","iconIndexBuffer","textVertexBuffer","textDDVertexBuffer","textIndexBuffer","circleVertexBuffer","circleIndexBuffer"];return function(e){function t(){for(var t,i=[],n=0;n<arguments.length;n++)i[n]=arguments[n];var o=e.call(this)||this;return o._renderBuckets=[],o._vectorTileData=null,o._symbolUpdateData=null,o.coords=[0,0],o.bounds=[0,0,0,0],o.tileTransform={transform:r.mat4f32.create(),displayCoord:a.vec2f32.create()},o.stencilData={mask:0,reference:0},i.length>0&&(t=o.acquire).call.apply(t,[o].concat(i)),o}return i(t,e),t.prototype.reset=function(){l.pool.release(this.key),this.key=null,this.coords[0]=0,this.coords[1]=0,this.bounds[0]=0,this.bounds[1]=0,this.bounds[2]=0,this.bounds[3]=0,this.width=0,this.height=0,this.resolution=null,this.rotation=0,this._vectorTileData=null,this.styleLayers=null,this.client=null,this.id=null,this.tileTransform.transform.fill(0),this.tileTransform.displayCoord.fill(0),this.stencilData.mask=0,this.stencilData.reference=0,this._renderBuckets.length=0,this._symbolUpdateData=null,this.stage=null},t.prototype.acquire=function(e,t,i,n){this.key=e;var r=t.lodAt(e.level),a=null!==r?r.resolution:0,s=t.size[0]*a,l=t.origin,d=e.col*s,u=e.row*s,c=t.spatialReference,f=0;if(c&&(c._isWrappable?c._isWrappable():c.isWrappable)){var h=o.getInfo(c);f=h.valid[1]-h.valid[0]}var _=e.world*f,p=l.x+d+_,m=l.y-u,v=p+s,g=m-s;this.coords[0]=p,this.coords[1]=m,this.bounds[0]=p,this.bounds[1]=m,this.bounds[2]=v,this.bounds[3]=g,this.widthInPixels=t.size[1],this.coordRange=4096,this.resolution=a,this.rotation=n,this.styleLayers=i,this.id=e.id},t.prototype.setData=function(e,t){this._vectorTileData=e,this.client=t},t.prototype.updateSymbolData=function(e){e&&(this._symbolUpdateData=e,this.requestRender())},t.prototype.updateTileData=function(e){this._vectorTileData=e,this.stage.requestRender()},t.prototype.dispose=function(){for(var e=["fillVertexArrayObject","fillDDVertexArrayObject","outlineVertexArrayObject","lineVertexArrayObject","lineDDVertexArrayObject","iconVertexArrayObject","iconDDVertexArrayObject","textVertexArrayObject","textDDVertexArrayObject","circleVertexArrayObject","fillVertexBuffer","fillDDVertexBuffer","fillIndexBuffer","outlineVertexBuffer","outlineDDVertexBuffer","outlineIndexBuffer","lineVertexBuffer","lineDDVertexBuffer","lineIndexBuffer","iconVertexBuffer","iconDDVertexBuffer","iconIndexBuffer","textVertexBuffer","textDDVertexBuffer","textIndexBuffer","circleVertexBuffer","circleIndexBuffer","texture"],t=0;t<e.length;++t){var i=e[t];this[i]&&(this[i].dispose(),this[i]=null)}this._renderBuckets.length=0},t.prototype.getCpuMemoryUsage=function(){return null!=this._vectorTileData&&this._vectorTileData.bufferData?this._vectorTileData.bufferData.reduce(function(e,t){return e+t.byteLength},0)+this._vectorTileData.bufferDataInfo.byteLength+this._vectorTileData.bucketDataInfo.byteLength:0},t.prototype.getGpuMemoryUsage=function(){var e=this,t=c.reduce(function(t,i){return e[i]?t+e[i].size:t},0);return this.texture&&(t+=this.texture.descriptor.width*this.texture.descriptor.height*4),t},t.prototype.attachWithContext=function(e){this.stage={context:e},this.attached=this.attach()},t.prototype._commitChanges=function(){this._vectorTileData&&(this.dispose(),this._createRenderBuckets(),this._createBufferObjects(),this._vectorTileData=null)},t.prototype._createRenderBuckets=function(){for(var e=new Uint32Array(this._vectorTileData.bucketDataInfo),t=e.length,i=0;i<t;){var n=e[i];switch(e[i+1]){case 0:var r=new d.BackgroundRenderBucket;r.layerID=n,this._renderBuckets.push(r),i+=2;break;case 1:var a=new d.FillRenderBucket;a.layerID=n,a.triangleElementStart=e[i+2],a.triangleElementCount=e[i+3],a.outlineElementStart=e[i+4],a.outlineElementCount=e[i+5],this._renderBuckets.push(a),i+=6;break;case 2:var o=new d.LineRenderBucket;o.layerID=n,o.triangleElementStart=e[i+2],o.triangleElementCount=e[i+3],this._renderBuckets.push(o),i+=4;break;case 3:var s=new d.SymbolRenderBucket;s.layerID=n,s.isSDF=0!==e[i+2];var l=i+3,u=e[l];if(l++,u>0)for(var c=void 0,f=void 0,h=void 0,_=0;_<u;_++)c=e[l],f=e[l+1],h=e[l+2],s.markerPerPageElementsMap.set(c,[f,h]),l+=3;var p=l,m=e[p];if(p++,m>0)for(c=void 0,f=void 0,h=void 0,_=0;_<m;_++)c=e[p],f=e[p+1],h=e[p+2],s.glyphPerPageElementsMap.set(c,[f,h]),p+=3;this._renderBuckets.push(s),i+=5+3*u+3*m;break;case 4:var v=new d.CircleRenderBucket;v.layerID=n,v.triangleElementStart=e[i+2],v.triangleElementCount=e[i+3],this._renderBuckets.push(v),i+=4;break;default:i+=2}}},t._createBufferToObject=function(){var e=[];return e[1]={create:u.createVertex,var:"fillVertexBuffer"},e[2]={create:u.createVertex,var:"fillDDVertexBuffer"},e[3]={create:u.createIndex,var:"fillIndexBuffer"},e[4]={create:u.createVertex,var:"outlineVertexBuffer"},e[5]={create:u.createVertex,var:"outlineDDVertexBuffer"},e[6]={create:u.createIndex,var:"outlineIndexBuffer"},e[7]={create:u.createVertex,var:"lineVertexBuffer"},e[8]={create:u.createVertex,var:"lineDDVertexBuffer"},e[9]={create:u.createIndex,var:"lineIndexBuffer"},e[10]={create:u.createVertex,var:"iconVertexBuffer"},e[11]={create:u.createVertex,var:"iconDDVertexBuffer"},e[12]={create:u.createIndex,var:"iconIndexBuffer"},e[13]={create:u.createVertex,var:"textVertexBuffer"},e[14]={create:u.createVertex,var:"textDDVertexBuffer"},e[15]={create:u.createIndex,var:"textIndexBuffer"},e[16]={create:u.createVertex,var:"circleVertexBuffer"},e[17]={create:u.createIndex,var:"circleIndexBuffer"},e},t.prototype._createBufferObjects=function(){for(var e=this.stage.context,i=new Uint32Array(this._vectorTileData.bufferDataInfo),n=i.length,r=0,a=0;a<n;a+=2,r++){var o=i[a];if(!(i[a+1]<=0||0===this._vectorTileData.bufferData[r].byteLength)){var s=t.bufferToObject[o];s&&(this[s.var]?this[s.var].setData(this._vectorTileData.bufferData[r]):this[s.var]=s.create(e,35044,this._vectorTileData.bufferData[r]))}}},t.prototype.detach=function(){this.isReady&&this.client.invoke("destructTileData",this.id),this.dispose(),e.prototype.detach.call(this)},t.prototype.doRender=function(e){if(this.visible&&this.isReady){var t=this.stage.context,i=e.renderer;if(t&&i){this._commitChanges();var n=e.drawphase;this._symbolUpdateData&&(this._updateSymbolData(e,this._symbolUpdateData),this._symbolUpdateData=null),t.setStencilFunction(514,this.stencilData.reference,this.stencilData.mask);var r,a=this.styleLayers,o=void 0!==e.layerOpacity?e.layerOpacity:1;if(0!==o){var s=this._renderBuckets.length;if(0===n)for(var l=s-1;l>=0;l--){var d=this._renderBuckets[l];if(r=a.layers[d.layerID],!d||!r)return;1!==d.type&&0!==d.type||!d.hasData()||i.renderBucket(t,d,e.displayLevel,e.requiredLevel,n,this,r,o)}else for(l=0;l<s;l++){d=this._renderBuckets[l];if(r=a.layers[d.layerID],!d||!r)return;d.hasData()&&i.renderBucket(t,d,e.displayLevel,e.requiredLevel,n,this,r,o)}}}}},t.prototype._updateSymbolData=function(e,t){if(!t||!t.bucketDataInfo)return!0;var i=new Uint32Array(t.bucketDataInfo),n=i.length;if(0===n)return!0;if(!this.isReady)return this.requestRender(),!1;for(var r=this.stage.context,a=new Uint32Array(t.bufferDataInfo),o=a.length,s=0,l=0;l<o;l+=2,s++)switch(a[l]){case 10:this.iconVertexBuffer&&(this.iconVertexBuffer.dispose(),this.iconVertexBuffer=null),this.iconVertexBuffer=u.createVertex(r,35044,t.bufferData[s]);break;case 11:this.iconDDVertexBuffer&&(this.iconDDVertexBuffer.dispose(),this.iconDDVertexBuffer=null),this.iconDDVertexBuffer=u.createVertex(r,35044,t.bufferData[s]);break;case 12:this.iconIndexBuffer&&(this.iconIndexBuffer.dispose(),this.iconIndexBuffer=null),this.iconIndexBuffer=u.createIndex(r,35044,t.bufferData[s]);break;case 13:this.textVertexBuffer&&(this.textVertexBuffer.dispose(),this.textVertexBuffer=null),this.textVertexBuffer=u.createVertex(r,35044,t.bufferData[s]);break;case 14:this.textDDVertexBuffer&&(this.textDDVertexBuffer.dispose(),this.textDDVertexBuffer=null),this.textDDVertexBuffer=u.createVertex(r,35044,t.bufferData[s]);break;case 15:this.textIndexBuffer&&(this.textIndexBuffer.dispose(),this.textIndexBuffer=null),this.textIndexBuffer=u.createIndex(r,35044,t.bufferData[s])}for(var c=[],f=0;f<this._renderBuckets.length;f++)this._renderBuckets[f]instanceof d.SymbolRenderBucket||c.push(this._renderBuckets[f]);this._renderBuckets=c;for(var h,_=0;_<n;){var p=i[_];(h=new d.SymbolRenderBucket).layerID=p,h.isSDF=0!==i[_+2],this.styleLayers.layers.length>h.layerID&&this.styleLayers.layers[h.layerID].type===h.type&&c.push(h);var m=_+3,v=i[m];if(m++,v>0)for(var g=void 0,x=void 0,y=void 0,b=0;b<v;b++)g=i[m],x=i[m+1],y=i[m+2],h.markerPerPageElementsMap.set(g,[x,y]),m+=3;var w=m,D=i[w];if(w++,D>0)for(g=void 0,x=void 0,y=void 0,b=0;b<D;b++)g=i[w],x=i[w+1],y=i[w+2],h.glyphPerPageElementsMap.set(g,[x,y]),w+=3;_+=5+3*v+3*D}return this.iconVertexArrayObject&&(this.iconVertexArrayObject.dispose(),this.iconVertexArrayObject=null),this.iconDDVertexArrayObject&&(this.iconDDVertexArrayObject.dispose(),this.iconDDVertexArrayObject=null),this.textVertexArrayObject&&(this.textVertexArrayObject.dispose(),this.textVertexArrayObject=null),this.textDDVertexArrayObject&&(this.textDDVertexArrayObject.dispose(),this.textDDVertexArrayObject=null),!0},t.pool=new n(t),t.bufferToObject=t._createBufferToObject(),t}(s.DisplayObject)}.apply(null,n))||(e.exports=r)},B7Pw:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("zp6E"),i("v7zm"),i("qMld")],void 0===(r=function(e,t,i,n,r){var a=function(){function e(e){if(this._metrics=[],this._bitmaps=[],e)for(;e.next();)switch(e.tag()){case 1:for(var t=e.getMessage();t.next();)switch(t.tag()){case 3:for(var i=t.getMessage(),n=void 0,r=void 0,a=void 0,o=void 0,s=void 0,l=void 0,d=void 0;i.next();)switch(i.tag()){case 1:n=i.getUInt32();break;case 2:r=i.getBytes();break;case 3:a=i.getUInt32();break;case 4:o=i.getUInt32();break;case 5:s=i.getSInt32();break;case 6:l=i.getSInt32();break;case 7:d=i.getUInt32();break;default:i.skip()}n&&(this._metrics[n]={width:a,height:o,left:s,top:l,advance:d},this._bitmaps[n]=r);break;default:t.skip()}break;default:e.skip()}}return e.prototype.getMetrics=function(e){return this._metrics[e]},e.prototype.getBitmap=function(e){return this._bitmaps[e]},e}(),o=function(){function e(){this._ranges=[]}return e.prototype.getRange=function(e){return this._ranges[e]},e.prototype.addRange=function(e,t){this._ranges[e]=t},e}();return function(){function e(e){this._glyphInfo={},this._baseURL=e}return e.prototype.getRange=function(e,t){var o=this._getFontStack(e);if(o.getRange(t))return r.resolve();var s=256*t,l=s+255,d=this._baseURL.replace("{fontstack}",e).replace("{range}",s+"-"+l);return i(d,{responseType:"array-buffer"}).then(function(e){o.addRange(t,new a(new n(new Uint8Array(e.data),new DataView(e.data))))}).catch(function(){o.addRange(t,new a)})},e.prototype.getGlyph=function(e,t){var i=this._getFontStack(e);if(i){var n=Math.floor(t/256);if(!(n>256)){var r=i.getRange(n);if(r)return{metrics:r.getMetrics(t),bitmap:r.getBitmap(t)}}}},e.prototype._getFontStack=function(e){var t=this._glyphInfo[e];return t||(t=this._glyphInfo[e]=new o),t},e}()}.apply(null,n))||(e.exports=r)},Brhx:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("xhoE"),i("BcWh")],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=function(e){function t(){var t=null!==e&&e.apply(this,arguments)||this;return t._renderRequestedCalled=!1,t._attached=!1,t._isReady=!1,t._opacity=1,t.renderRequested=!1,t._visible=!0,t}return i(t,e),Object.defineProperty(t.prototype,"attached",{get:function(){return this._attached},set:function(e){this._attached!==e&&(this._attached=e,e?this.hasEventListener("attach")&&this.emit("attach"):this.hasEventListener("detach")&&this.emit("detach"))},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"isReady",{get:function(){return this._attached&&this._isReady},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"opacity",{get:function(){return this._opacity},set:function(e){this._opacity!==e&&(this._opacity=e,this.requestRender())},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"visible",{get:function(){return this._visible},set:function(e){this._visible!==e&&(this._visible=e,this.requestRender())},enumerable:!0,configurable:!0}),t.prototype.attach=function(){return this.ready(),!0},t.prototype.detach=function(){},t.prototype.processRender=function(e){this.visible&&this.attached&&(this._renderRequestedCalled=!1,this.doRender(e),this._renderRequestedCalled||(this.renderRequested=!1),this.hasEventListener("post-render")&&this.emit("post-render"))},t.prototype.requestRender=function(){var e=this.renderRequested;this._renderRequestedCalled=!0,this.renderRequested=!0,this.parent&&this.parent.requestChildRender(this),e!==this.renderRequested&&this.hasEventListener("will-render")&&this.emit("will-render")},t.prototype.dispose=function(){},t.prototype.ready=function(){this._isReady=!0,this.emit("isReady")},t}(n);t.DisplayObject=r}.apply(null,n))||(e.exports=r)},"Ix/S":function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("H1tY"),i("qMld"),i("2ZMW"),i("66Fz"),i("Zp3t")],void 0===(r=function(e,t,i,n,r,a,o){var s;return function(){function e(e,t,n){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,!s&&i("stable-symbol-rendering")&&(s=new Set),this.width=e,this.height=t,this._glyphSource=n,this._binPack=new a(e-4,t-4),this._glyphData.push(new Uint8Array(e*t)),this._dirties.push(!0),this._textures.push(void 0)}return e.prototype.getGlyphItems=function(e,t,o){for(var l=this,d=[],u=this._glyphSource,c=new Set,f=0,h=o;f<h.length;f++){var _=h[f],p=Math.floor(_*(1/256));c.add(p)}var m=[];return c.forEach(function(e){if(e<=256){var i=t+e;if(l._rangePromises.has(i))m.push(l._rangePromises.get(i));else{var n=u.getRange(t,e).then(function(){l._rangePromises.delete(i)},function(){l._rangePromises.delete(i)});l._rangePromises.set(i,n),m.push(n)}}}),n.all(m).then(function(e){var n,f=l._glyphIndex[t];if(f||(f={},l._glyphIndex[t]=f),i("stable-symbol-rendering")){s.clear();for(var h=0,_=o;h<_.length;h++){var p=_[h];s.add(p)}var m=[];c.forEach(function(e){m.push(e)}),m.sort(),n=[];for(var v=0,g=m;v<g.length;v++)for(var x=g[v],y=0;y<256;++y)n.push(256*x+y)}else n=o;for(var b=0,w=n;b<w.length;b++){var D=f[p=w[b]];if(D)i("stable-symbol-rendering")&&!s.has(p)||(d[p]={sdf:!0,rect:D.rect,metrics:D.metrics,page:D.page});else{var T=u.getGlyph(t,p);if(T&&T.metrics){var V=T.metrics,A=void 0;if(0===V.width)A=new r(0,0,0,0);else{var S=V.width+6,I=V.height+6,z=S%4?4-S%4:4,M=I%4?4-I%4:4;1===z&&(z=5),1===M&&(M=5),(A=l._binPack.allocate(S+z,I+M)).isEmpty&&(l._dirties[l._currentPage]||(l._glyphData[l._currentPage]=null),l._currentPage=l._glyphData.length,l._glyphData.push(new Uint8Array(l.width*l.height)),l._dirties.push(!0),l._textures.push(void 0),l._binPack=new a(l.width-4,l.height-4),A=l._binPack.allocate(S+z,I+M));var C=l._glyphData[l._currentPage],E=T.bitmap,R=void 0,O=void 0;if(E)for(var P=0;P<I;P++){R=S*P,O=l.width*(A.y+P+1)+A.x;for(var F=0;F<S;F++)C[O+F+1]=E[R+F]}}f[p]={rect:A,metrics:V,tileIDs:null,page:l._currentPage},i("stable-symbol-rendering")&&!s.has(p)||(d[p]={sdf:!0,rect:A,metrics:V,page:l._currentPage}),l._dirties[l._currentPage]=!0}}}return d})},e.prototype.removeGlyphs=function(e){for(var t in this._glyphIndex){var i=this._glyphIndex[t];if(i){var n=void 0;for(var r in i)if((n=i[r]).tileIDs.delete(e),0===n.tileIDs.size){for(var a=this._glyphData[n.page],o=n.rect,s=void 0,l=void 0,d=0;d<o.height;d++)for(s=this.width*(o.y+d)+o.x,l=0;l<o.width;l++)a[s+l]=0;delete i[r],this._dirties[n.page]=!0}}}},e.prototype.bind=function(e,t,i,n){void 0===n&&(n=0),this._textures[i]||(this._textures[i]=new o(e,{pixelFormat:6406,dataType:5121,width:this.width,height:this.height},new Uint8Array(this.width*this.height)));var r=this._textures[i];r.setSamplingMode(t),this._dirties[i]&&r.setData(this._glyphData[i]),e.bindTexture(r,n),this._dirties[i]=!1},e.prototype.dispose=function(){this._binPack=null;for(var e=0,t=this._textures;e<t.length;e++){var i=t[e];i&&i.dispose()}this._textures.length=0},e}()}.apply(null,n))||(e.exports=r)},RR1D:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("FXVB"),i("oZZu"),i("ab6c"),i("vlC2"),i("j2SP"),i("BEeJ"),i("lr+P"),i("z2+Q")],void 0===(r=function(e,t,i,n,r,a,o,s,l,d){return function(){function e(e){this._initialized=!1,this._viewProjMat=n.mat4f32.create(),this._offsetVector=a.vec3f32.create(),this._color=o.vec4f32.create(),this._dashArray=r.vec2f32.create(),this._programOptions={id:!1,dd:!1,pattern:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,n,r,a,o,d,u,c,f,h){if(0!==t.triangleElementCount){this._initialized||this._initialize(e);var _=o.tileTransform.transform,p=o.coordRange/512,m=d.getPaintValue("line-translate",n);if(0!==m[0]||0!==m[1]){i.mat4.copy(this._viewProjMat,o.tileTransform.transform);var v=m[0],g=m[1],x=0,y=0,b=(1<<o.key.level)/Math.pow(2,n)*p,w=a.rotation;if(1===d.getPaintValue("line-translate-anchor",n)){var D=-s.C_DEG_TO_RAD*w,T=Math.sin(D),V=Math.cos(D);x=b*(v*V-g*T),y=b*(v*T+g*V)}else x=b*v,y=b*g;this._offsetVector[0]=x,this._offsetVector[1]=y,this._offsetVector[2]=0,i.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),_=this._viewProjMat}var A=d.getPaintValue("line-pattern",n),S=void 0!==A,I=1/f,z=d.getPaintValue("line-blur",n),M=d.hasDataDrivenColor?[1,1,1,1]:d.getPaintValue("line-color",n),C=d.hasDataDrivenOpacity?1:d.getPaintValue("line-opacity",n),E=d.hasDataDrivenWidth?1:d.getPaintValue("line-width",n),R=C*M[3]*h;this._color[0]=R*M[0],this._color[1]=R*M[1],this._color[2]=R*M[2],this._color[3]=R;var O,P=d.hasDataDrivenLine,F=3===r;F&&(O=l.int32To4Bytes(t.layerID));var k=this._getLineVAO(e,o,P);if(k){e.bindVAO(k);var B=(F?1:0)<<2|(P?1:0)<<1|(S?1:0),U=this._programOptions;U.id=F,U.dd=P,U.pattern=S;var L=this._programCache.getProgram(3,B,U);if(e.bindProgram(L),L.setUniformMatrix4fv("u_transformMatrix",_),L.setUniformMatrix4fv("u_extrudeMatrix",c),L.setUniform2fv("u_normalized_origin",o.tileTransform.displayCoord),L.setUniform1f("u_depth",d.z),L.setUniform1f("u_blur",z),L.setUniform1f("u_antialiasing",I),L.setUniform4fv("u_color",this._color),L.setUniform1f("u_width",E),F&&L.setUniform4f("u_id",O[0],O[1],O[2],O[3]),S){var N=u.getMosaicItemPosition(A,!0);N&&(u.bind(e,9729,N.page,5),L.setUniform2f("u_pattern_tl",N.tl[0],N.br[1]),L.setUniform2f("u_pattern_br",N.br[0],N.tl[1]),L.setUniform2f("u_spriteSize",p*N.size[0],N.size[1]),L.setUniform1i("u_texture",5))}else{var j=d.getPaintValue("line-dasharray",n);j.length<2&&(j=[1,-1]);var H=p;this._dashArray[0]=H*j[0],this._dashArray[1]=H*j[1],L.setUniform2fv("u_dasharray",this._dashArray)}e.drawElements(4,t.triangleElementCount,5125,12*t.triangleElementStart),e.bindVAO()}}},e.prototype._initialize=function(e){return!!this._initialized||(this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:12,normalized:!1,divisor:0},{name:"a_offsetAndNormal",count:4,type:5120,offset:4,stride:12,normalized:!1,divisor:0},{name:"a_accumulatedDistance",count:2,type:5123,offset:8,stride:12,normalized:!1,divisor:0}]},this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:20,normalized:!1,divisor:0},{name:"a_offsetAndNormal",count:4,type:5120,offset:4,stride:20,normalized:!1,divisor:0},{name:"a_accumulatedDistance",count:2,type:5122,offset:8,stride:20,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:12,stride:20,normalized:!0,divisor:0},{name:"a_width",count:1,type:5126,offset:16,stride:20,normalized:!1,divisor:0}]},this._initialized=!0,!0)},e.prototype._getLineVAO=function(e,t,i){if(i){if(t.lineDDVertexArrayObject)return t.lineDDVertexArrayObject;var n=t.lineDDVertexBuffer,r=t.lineIndexBuffer;return n&&r?(t.lineDDVertexArrayObject=new d(e,this._programCache.getProgramAttributes(3),this._vertexAttributesDD,{geometry:n},r),t.lineDDVertexArrayObject):null}if(t.lineVertexArrayObject)return t.lineVertexArrayObject;n=t.lineVertexBuffer,r=t.lineIndexBuffer;return n&&r?(t.lineVertexArrayObject=new d(e,this._programCache.getProgramAttributes(3),this._vertexAttributes,{geometry:n},r),t.lineVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},RkId:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("FXVB"),i("oZZu"),i("vlC2"),i("j2SP"),i("BEeJ"),i("lr+P"),i("z2+Q")],void 0===(r=function(e,t,i,n,r,a,o,s,l){return function(){function e(e){this._viewProjMat=n.mat4f32.create(),this._offsetVector=r.vec3f32.create(),this._color=a.vec4f32.create(),this._strokeColor=a.vec4f32.create(),this._initialized=!1,this._programOptions={id:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,n,r,a,l,d,u,c){if(0!==t.triangleElementCount){this._initialized||this._initialize(e);var f=d.hasDataDrivenRadius?1:d.getPaintValue("circle-radius",n),h=d.hasDataDrivenColor?[1,1,1,1]:d.getPaintValue("circle-color",n),_=d.hasDataDrivenOpacity?1:d.getPaintValue("circle-opacity",n),p=d.hasDataDrivenStrokeWidth?1:d.getPaintValue("circle-stroke-width",n),m=d.hasDataDrivenStrokeColor?[1,1,1,1]:d.getPaintValue("circle-stroke-color",n),v=d.hasDataDrivenStrokeOpacity?1:d.getPaintValue("circle-stroke-opacity",n),g=d.hasDataDrivenBlur?0:d.getPaintValue("circle-blur",n),x=_*h[3]*c;this._color[0]=x*h[0],this._color[1]=x*h[1],this._color[2]=x*h[2],this._color[3]=x,x=v*m[3]*c,this._strokeColor[0]=x*m[0],this._strokeColor[1]=x*m[1],this._strokeColor[2]=x*m[2],this._strokeColor[3]=x;var y=l.tileTransform.transform,b=d.getPaintValue("circle-translate",n);if(0!==b[0]||0!==b[1]){i.mat4.copy(this._viewProjMat,l.tileTransform.transform);var w=b[0],D=b[1],T=0,V=0,A=l.coordRange/512,S=(1<<l.key.level)/Math.pow(2,n)*A;if(1===d.getPaintValue("circle-translate-anchor",n)){var I=-o.C_DEG_TO_RAD*a,z=Math.sin(I),M=Math.cos(I);T=S*(w*M-D*z),V=S*(w*z+D*M)}else T=S*w,V=S*D;this._offsetVector[0]=T,this._offsetVector[1]=V,this._offsetVector[2]=0,i.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),y=this._viewProjMat}var C=this._getCircleVAO(e,l);if(C){e.bindVAO(C);var E=3===r,R=E?1:0,O=this._programOptions;O.id=E;var P=this._programCache.getProgram(5,R,O);if(e.bindProgram(P),P.setUniformMatrix4fv("u_transformMatrix",y),P.setUniformMatrix4fv("u_extrudeMatrix",u),P.setUniform2fv("u_normalized_origin",l.tileTransform.displayCoord),P.setUniform1f("u_depth",d.z),P.setUniform1f("u_radius",f),P.setUniform4fv("u_color",this._color),P.setUniform1f("u_blur",g),P.setUniform1f("u_stroke_width",p),P.setUniform4fv("u_stroke_color",this._strokeColor),P.setUniform1f("u_antialiasingWidth",1.2),E){var F=s.int32To4Bytes(t.layerID);P.setUniform4f("u_id",F[0],F[1],F[2],F[3])}e.drawElements(4,t.triangleElementCount,5125,12*t.triangleElementStart),e.bindVAO()}}},e.prototype._initialize=function(e){return!!this._initialized||(this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:4,stride:16,normalized:!0,divisor:0},{name:"a_stroke_color",count:4,type:5121,offset:8,stride:16,normalized:!0,divisor:0},{name:"a_data",count:4,type:5121,offset:12,stride:16,normalized:!1,divisor:0}]},this._initialized=!0,!0)},e.prototype._getCircleVAO=function(e,t){if(t.circleVertexArrayObject)return t.circleVertexArrayObject;var i=t.circleVertexBuffer,n=t.circleIndexBuffer;return i&&n?(t.circleVertexArrayObject=new l(e,this._programCache.getProgramAttributes(5),this._vertexAttributes,{geometry:i},n),t.circleVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},Rrc3:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("H1tY")],void 0===(r=function(e,t,i){return function(){function e(t,n){this._context=t,this._desc=n,this._glName=null,this._id=-1;var r=this._context.gl;i("esri-webgl-debug")&&this._context.instanceCounter.incrementCount(5),this._id=++e._nextId,this._glName=r.createRenderbuffer(),this._context.bindRenderbuffer(this),r.renderbufferStorage(r.RENDERBUFFER,n.internalFormat,n.width,n.height)}return Object.defineProperty(e.prototype,"descriptor",{get:function(){return this._desc},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"id",{get:function(){return this._id},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"glName",{get:function(){return this._glName},enumerable:!0,configurable:!0}),e.prototype.resize=function(e,t){var i=this._context.gl,n=this._desc;n.width===e&&n.height===t||(n.width=e,n.height=t,this._context.bindRenderbuffer(this),i.renderbufferStorage(i.RENDERBUFFER,n.internalFormat,n.width,n.height))},e.prototype.dispose=function(){this._glName&&(this._context.gl.deleteRenderbuffer(this._glName),this._glName=null),i("esri-webgl-debug")&&this._context.instanceCounter.decrementCount(5),this._context=null},e._nextId=0,e}()}.apply(null,n))||(e.exports=r)},"U+RI":function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){return function(){function e(e){this._array=[],this._stride=e}return Object.defineProperty(e.prototype,"array",{get:function(){return this._array},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"index",{get:function(){return 4*this._array.length/this._stride},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"itemSize",{get:function(){return this._stride},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"sizeInBytes",{get:function(){return 4*this._array.length},enumerable:!0,configurable:!0}),e.prototype.reset=function(){this.array.length=0},e.prototype.toBuffer=function(){return new Uint32Array(this._array).buffer},e.i1616to32=function(e,t){return 65535&e|t<<16},e.i8888to32=function(e,t,i,n){return 255&e|(255&t)<<8|(255&i)<<16|n<<24},e.i8816to32=function(e,t,i){return 255&e|(255&t)<<8|i<<16},e}()}.apply(null,n))||(e.exports=r)},U6PA:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("zp6E"),i("H1tY"),i("ZHL0"),i("qMld"),i("ADZV"),i("8V7H"),i("f3JK"),i("BEeJ"),i("Ix/S"),i("B7Pw"),i("c8HX"),i("rGws"),i("AvrD"),i.dj.m(e)],void 0===(r=function(e,t,i,n,r,a,o,s,l,d,u,c,f,h,_,p){var m=new r(10),v=new Map;return function(){function t(e,t,i,n){this.devicePixelRatio=t,this.allowUpdates=i,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._updateQueue=new Map,this._ongoingRequests=new Map,this._vectorTileLayer=e,this._container=n}return t.prototype.destroy=function(){this.stop(),this._vectorTileLayer=null,this._spriteMosaic&&(this._spriteMosaic.dispose(),this._spriteMosaic=null),this._glyphMosaic&&(this._glyphMosaic.dispose(),this._glyphMosaic=null)},Object.defineProperty(t.prototype,"initialized",{get:function(){return this._broadcastPromise&&this._broadcastPromise.isFulfilled()},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"spriteMosaic",{get:function(){return this._spriteMosaic},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"glyphMosaic",{get:function(){return this._glyphMosaic},enumerable:!0,configurable:!0}),Object.defineProperty(t.prototype,"ongoingRequestCount",{get:function(){return this._ongoingRequests.size},enumerable:!0,configurable:!0}),t.prototype.start=function(){var t=this;this.stop();var i=[],r=this._vectorTileLayer.loadSpriteSource(this.devicePixelRatio).then(function(e){t._spriteMosaic=new f(1024,1024,250),t._spriteMosaic.setSpriteSource(e),n("stable-symbol-rendering")&&t._spriteMosaic.preloadSpriteItems()});i.push(r);var l=this._vectorTileLayer.styleRepository,d=new c(l.glyphs);this._glyphMosaic=new u(1024,1024,d);var h=this._vectorTileLayer.sourceNameToSource;for(var _ in h)i.push(this._fetchTileMap(h[_]));var m=s.open(o.getAbsMid("./WorkerTileHandler",e,p),{client:this}).then(function(e){t._connection=e});return i.push(m),this._broadcastPromise=a.all(i).then(function(){return t._connection.broadcast("setLayers",l.styleJSON)}),this._broadcastPromise},t.prototype.stop=function(){this._broadcastPromise&&!this._broadcastPromise.isFulfilled()&&this._broadcastPromise.cancel(),this._updateQueue.forEach(function(e){return e.cancel()}),this._ongoingRequests.forEach(function(e){return e.cancel()}),this._connection&&(this._connection.close(),this._connection=null)},t.prototype.updateStyle=function(){this._updateQueue.forEach(function(e){return e.cancel()}),this._updateQueue.clear(),this._ongoingRequests.forEach(function(e){return e.cancel()}),this._ongoingRequests.clear();var e,t=this._vectorTileLayer.styleRepository,i=a.create(function(t){e=t});return a.all(this._connection.broadcast("updateStyle",t.styleJSON)).then(function(){return e()}),this._broadcastPromise=i,i},t.prototype.updateTile=function(e,t){var i=this;if(!this.allowUpdates)return a.resolve(null);if(!this._broadcastPromise.isFulfilled()||!this._connection)return a.reject(new Error("no connection"));var n=Math.round(d.degToByte(t.state.rotation));if(e.rotation===n)return a.resolve(null);var r,o=e.key;return this._updateQueue.has(o.id)&&((r=this._updateQueue.get(o.id)).cancel(),this._updateQueue.delete(o.id)),e.rotation=n,r=e.client.invoke("updateSymbols",{key:e.id,rotation:n}).then(function(t){return i._updateQueue.delete(o.id),e.updateSymbolData(t),t}).catch(function(e){"cancel"!==e.dojoType&&i._updateQueue.delete(o.id)}),this._updateQueue.set(e.id,r),r},t.prototype.updateTileData=function(e){for(var t,i=e.tileId,n=this._container.children,r=0;r<n.length;r++)if((t=n[r]).id===i){t.updateTileData(e.tileData);break}},t.prototype.getVectorTile=function(e,t,i,n){void 0===n&&(n=0);var r=new l(e,t,i,0),o=new _(r,this._vectorTileLayer.tileInfo,this._vectorTileLayer.styleRepository,0),s=this.getTileData(r,0).then(function(e){return e?o.setData(e.tileData,e.client):o.setData(null,null),o});return a.create(function(e,t){s.then(function(t){return e(t)}).catch(function(e){return t(e)})})},t.prototype.getTileData=function(e,t){var i=this;if(!this._broadcastPromise.isFulfilled()||!this._connection)return a.reject(new Error("no connection"));var n=e.id;if(this._ongoingRequests.has(n))return this._ongoingRequests.get(n);var r=this._vectorTileLayer.sourceNameToSource,o=[],s=[];for(var l in r){var u=r[l],c=u.getRefKey(e);o.push(c),s.push(u.name)}var f=!1,h=a.eachAlways(o).then(function(r){for(var o=Math.round(d.degToByte(t)),l=[],u=0;u<r.length;u++)if(null==r[u].value)l.push(a.reject("getRefKey failed for source "+s[u]));else{var c=i._getTileData(e,r[u].value,s[u]).then(function(e){return e&&e.protobuff?e:(f=!0,i._ongoingRequests.delete(n),a.reject())});l.push(c)}return a.eachAlways(l).then(function(t){for(var s={},l=[],d=0;d<t.length;d++)if(t[d].value&&t[d].value.protobuff&&t[d].value.protobuff.byteLength>0){var u=r[d].value.toString();s[t[d].value.sourceName]={refKey:u,protobuff:t[d].value.protobuff},l.push(t[d].value.protobuff)}if(0===Object.keys(s).length)return f=!0,i._ongoingRequests.delete(n),a.resolve(null);var c=i._connection.getAvailableClient();return c.invoke("createTileAndParse",{key:e.toString(),rotation:o,cacheTile:i.allowUpdates,sourceName2DataAndRefKey:s},{transferList:l}).then(function(e){return f=!0,i._ongoingRequests.delete(n),{tileData:e,client:c}}).catch(function(t){return f=!0,i._ongoingRequests.delete(n),c.invoke("destructTileData",e.id),a.reject(t)})}).catch(function(e){return i._ongoingRequests.delete(n),a.reject(e)})}).catch(function(e){return i._ongoingRequests.delete(n),a.reject(e)});return f||this._ongoingRequests.set(n,h),h},t.prototype.getSprites=function(e){return this._spriteMosaic.getSpriteItems(e)},t.prototype.getGlyphs=function(e){return this._glyphMosaic.getGlyphItems(e.tileID,e.font,e.codePoints)},t.prototype.getStyleRepository=function(){return this._vectorTileLayer.styleRepository},t.prototype._getTileData=function(e,t,i){return this.fetchTileData(t.toString(),i).then(function(e){return{protobuff:e,sourceName:i}})},t.prototype._fetchTileMap=function(e){if(e.capabilities.operations.supportsTileMap&&e.tileIndex)return a.resolve();if(!e.tileMapURL)return a.resolve();var t=m.get(e.tileMapURL);if(t)return e.tileIndex=t,a.resolve();if(v.has(e.tileMapURL))return v.get(e.tileMapURL).then(function(t){e.tileIndex=new h(t.data)});var n=i(e.tileMapURL,{responseType:"json"});return n.then(function(t){e.tileIndex=new h(t.data),v.delete(e.tileMapURL),m.put(e.tileMapURL,e.tileIndex)}),v.set(e.tileMapURL,n),n},t.prototype.fetchTileData=function(e,t){var n=l.pool.acquire(e),r=this._vectorTileLayer.sourceNameToSource;if(!(t in r))return l.pool.release(n),a.reject(new Error("invalid source name"));var o=r[t].getSourceTileUrl(n.level,n.row,n.col);return l.pool.release(n),i(o,{responseType:"array-buffer"}).then(function(e){return e.data})},t}()}.apply(null,n))||(e.exports=r)},Uu9s:function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){return{background:{"background.frag":"uniform lowp vec4 u_color;\nvoid main() {\n  gl_FragColor = u_color;\n}\n","background.vert":"attribute vec2 a_pos;\n\nuniform highp mat3 u_dvsMat3;\nuniform mediump float u_coord_range;\nuniform mediump float u_depth;\n\nvoid main() {\n  vec3 v_pos = u_dvsMat3 * vec3(u_coord_range * a_pos, 1.0);\n  gl_Position = vec4(v_pos.xy, 0.0, 1.0);\n}\n"},bitBlit:{"bitBlit.frag":"uniform lowp sampler2D u_tex;\nuniform lowp float u_opacity;\n\nvarying mediump vec2 v_uv;\n\nvoid main() {\n  lowp vec4 color = texture2D(u_tex, v_uv);\n\n  // Note: output in pre-multiplied alpha for correct alpha compositing\n  gl_FragColor = color *  u_opacity;\n}\n","bitBlit.vert":"attribute vec2 a_pos;\nattribute vec2 a_tex;\n\nvarying mediump vec2 v_uv;\n\nvoid main(void) {\n  gl_Position = vec4(a_pos, 0.0, 1.0);\n  v_uv = a_tex;\n}\n"},highlight:{"blur.frag":"// A gaussian blur shader. It blurs the alpha channel of its input\n// according to 4 different sigma and stores the results into the\n// four channel of the target framebuffer.\n\n// It is intended to be called twice; the first time to perform an\n// horizontal blur, and a second time to perform a vertical blur.\n\n// This shader is used to turn the highlight mask into a highlight\n// map. The highlight map is an approximation of the signed distance\n// field of the mask.\n\n\n// Interpolated texture coordinates.\nvarying mediump vec2 v_texcoord;\n\n// Blur direction information. There are two possible\n// configurations that the host code can use.\n//  - [1, 0, 1/WIDTH, 0] Used when blurring horizontally. In this\n//    case u_direction[0] = 1 is expressed in pixel and is fed to\n//    the gauss function to produce the value of the gaussian weight\n//    for that pixel, while u_direction[2] = 1/WIDTH is in texel units\n//    and is used to sample the right texel from the texture map.\n//  - [0, 1, 0, 1/HEIGHT] Used when blurring vertically. In this\n//    case u_direction[1] = 1 is expressed in pixel and is fed to\n//    the gauss function to produce the value of the gaussian weight\n//    for that pixel, while u_direction[3] = 1/HEIGHT is in texel units\n//    and is used to sample the right texel from the texture map.\nuniform mediump vec4 u_direction;\n\n// Source to destination channel selection matrix.\nuniform mediump mat4 u_channelSelector;\n\n// The highlight map is obtained by blurring the alpha channel of the highlight\n// mask accroding to these 4 values of the gaussian's sigma parameter.\nuniform mediump vec4 u_sigmas;\n\n// This is the highlight mask if we have not blurred horizontally yet, otherwise\n// it is the horizontally blurred highlight map and blurring it one more time\n// vertically will complete the process.\nuniform sampler2D u_texture;\n\n// The gaussian kernel. Note that it lacks the normalization constant, because\n// we want to store it unnormalized in the highlight map (i.e. having a peak\n// value of 1). Note also that we are using the SIMD (single instruction, multiple\n// data) capabilities of the GPU to compute four different gaussian kernels, one\n// for each sigma.\nmediump vec4 gauss4(mediump vec2 dir) {\n  return exp(-dot(dir, dir) / (2.0 * u_sigmas * u_sigmas));\n}\n\n// Same as above but uses only channel 3, aka `w`, aka `q`, aka `a`.\nmediump float gauss1(mediump vec2 dir) {\n  return exp(-dot(dir, dir) / (2.0 * u_sigmas[3] * u_sigmas[3]));\n}\n\nmediump vec4 selectChannel(mediump vec4 sample) {\n  return u_channelSelector * sample;\n}\n\n// Sample the input texture and accumulated its gaussian weighted value and the\n// total weight; operates on all four channels.\nvoid accumGauss4(mediump float i, inout mediump vec4 tot, inout mediump vec4 weight) {\n  // Computes the gaussian weights, one for each sigma.\n  // Note that u_direction.xy is [1, 0] when blurring horizontally and [0, 1] when blurring vertically.\n  mediump vec4 w = gauss4(i * u_direction.xy);\n\n  // Accumumates the values.\n  // Note that u_direction.xy is [1/WIDTH, 0] when blurring horizontally and [0, 1/HEIGHT] when blurring vertically.\n  tot += selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw)) * w;\n\n  // Accumulates the weights.\n  weight += w;\n}\n\n// Sample the input texture and accumulated its gaussian weighted value and the\n// total weight; operates on a single channel.\nvoid accumGauss1(mediump float i, inout mediump float tot, inout mediump float weight) {\n  // Computes the gaussian weights, using only the last sigma.\n  // Note that u_direction.xy is [1, 0] when blurring horizontally and [0, 1] when blurring vertically.\n  mediump float w = gauss1(i * u_direction.xy);\n\n  // Accumumates the values.\n  // Note that u_direction.xy is [1/WIDTH, 0] when blurring horizontally and [0, 1/HEIGHT] when blurring vertically.\n  tot += selectChannel(texture2D(u_texture, v_texcoord + i * u_direction.zw))[3] * w;\n\n  // Accumulates the weights.\n  weight += w;\n}\n\nvoid main(void) {\n  // Initialize accumulated values and weights to zero.\n  mediump float tot = 0.0;\n  mediump float weight = 0.0;\n\n  // Accumulates enough samples. These will be taken\n  // horizontally or vertically depending on the value\n  // of u_direction.\n  accumGauss1(-4.0, tot, weight);\n  accumGauss1(-3.0, tot, weight);\n  accumGauss1(-2.0, tot, weight);\n  accumGauss1(-1.0, tot, weight);\n  accumGauss1(0.0, tot, weight);\n  accumGauss1(1.0, tot, weight);\n  accumGauss1(2.0, tot, weight);\n  accumGauss1(3.0, tot, weight);\n  accumGauss1(4.0, tot, weight);\n\n  // Originally we were performing 4 blurs in parallel;\n  // Now we store the only result in the alpha component.\n  // dari8942: In theory we could disable writing to rgb\n  // using a color mask but I don't really feel like messing\n  // with that now.\n  gl_FragColor = vec4(0.0, 0.0, 0.0, tot / weight);\n}\n","highlight.frag":"// Takes as input the highlight map, estimated the signed distance field,\n// and shades the fragments according to their estimated distance from the\n// edge of the highlighted feature.\n\n// A shade texture is used to turn distance values into colors; the shade\n// texture is basically a color gradient and is recomputed on the host\n// every time that the user alters the highlight options.\n\n// Interpolated texture coordinates.\nvarying mediump vec2 v_texcoord;\n\n// The highlight map. Each channel is a blurred\n// version of the alpha channel of the highlight mask.\n//  - Channel 0 (red) corresponds to a gaussian blur with sigma = u_sigmas[0];\n//  - Channel 1 (green) corresponds to a gaussian blur with sigma = u_sigmas[1];\n//  - Channel 2 (blue) corresponds to a gaussian blur with sigma = u_sigmas[2];\n//  - Channel 3 (alpha) corresponds to a gaussian blur with sigma = u_sigmas[3];\n// As of today, only channel 3 is used for distance estimation.\n// But the availability of different amounts of blur leaves the\n// door open to multi-scale approaches.\nuniform sampler2D u_texture;\n\n// The highlight map was obtained by blurring the alpha channel of the highlight\n// mask accroding to these 4 values of the gaussian's sigma parameter.\nuniform mediump vec4 u_sigmas;\n\n// A 1-D texture used to shade the highlight.\nuniform sampler2D u_shade;\n\n// The 1-D shade texture is spreaded between u_minMaxDistance[0] and u_minMaxDistance[1].\nuniform mediump vec2 u_minMaxDistance;\n\n// Signed distance estimation.\nmediump float estimateDistance() {\n  // Use the largest sigma and the corresponding distance value stored in the\n  // last channel of the highlight map.\n  mediump float sigma = u_sigmas[3];\n  mediump float y = texture2D(u_texture, v_texcoord)[3];\n\n  // Estimates the distance by linearization and local inversion around\n  // the inflection point. The inflection point is in x = 0.\n  const mediump float y0 = 0.5;                           // Value of the convolution at the inflection point.\n  mediump float m0 = 1.0 / (sqrt(2.0 * 3.1415) * sigma);  // Slope of the convolution at the inflection point.\n  mediump float d = (y - y0) / m0;                        // Inversion of a local linearization.\n\n  // Return the estimated distance.\n  return d;\n}\n\n// Shading based on estimated distance.\nmediump vec4 shade(mediump float d) {\n  // Maps the sampled distance from the [A, D] range (see HighlightRenderer::setHighlightOptions) to [0, 1].\n  mediump float mappedDistance = (d - u_minMaxDistance.x) / (u_minMaxDistance.y - u_minMaxDistance.x);\n\n  // Force to [0, 1]; it should not be necessary because the shade texture uses the CLAMP address mode, so\n  // this should happen anyway internally to the sampler, but in practice it is needed to avoid weird\n  // banding artifacts.\n  // We don't really know if we need this or not.\n  mappedDistance = clamp(mappedDistance, 0.0, 1.0);\n\n  // Sample the 1-D shade texture on its center line (i.e. on t=0.5).\n  return texture2D(u_shade, vec2(mappedDistance, 0.5));\n}\n\nvoid main(void) {\n  // Estimate the distance.\n  mediump float d = estimateDistance();\n\n  // Shade the distance.\n  gl_FragColor = shade(d);\n}\n","textured.vert":"// Identity vertex shader that outputs an untransformed 2-D vertex\n// and passes its texture coordinates unchanged to the interpolator.\n\n// Vertex position.\nattribute mediump vec2 a_position;\n\n// Texture coordinates.\nattribute mediump vec2 a_texcoord;\n\n// Texture coordinates to be interpolated.\nvarying mediump vec2 v_texcoord;\n\nvoid main(void) {\n  // Pass the position unchanged.\n  gl_Position = vec4(a_position, 0.0, 1.0);\n\n  // Pass the texture coordinates unchanged.\n  v_texcoord = a_texcoord;\n}\n"},magnifier:{"magnifier.frag":"uniform lowp vec4 u_background;\nuniform mediump sampler2D u_readbackTexture;\nuniform mediump sampler2D u_maskTexture;\nuniform mediump sampler2D u_overlyTexture;\n\nvarying mediump vec2 v_texCoord;\n\nvoid main(void)\n{\n  lowp vec4 color = texture2D(u_readbackTexture, v_texCoord);\n  color = color + (1.0 - color.a) * u_background;\n\n  // calculate the grayscale value of the mask:\n  lowp vec4 mask_color = texture2D(u_maskTexture, v_texCoord);\n  lowp float gray = 1.0 - dot(mask_color, vec4(0.3, 0.59, 0.11, 0));\n  // make all the map color outside the mask black\n  color *= gray;\n\n  lowp vec4 overley_color = texture2D(u_overlyTexture, v_texCoord);\n\n  // premultiply the overlay color\n  overley_color.rgb *= overley_color.a;\n  gl_FragColor = overley_color + (1.0 - overley_color.a) * color;\n}\n","magnifier.vert":"precision mediump float;\n\nattribute mediump vec2 a_pos; // encoded values are 0 and 1\n\nuniform mediump vec2 u_drawPos; // the center position of the magnifier\nuniform mediump float u_width; // the width of the magnifier in normalized display coords\nuniform mediump float u_height; // the height of the magnifier in normalized display coords\n\nvarying mediump vec2 v_texCoord;\n\n\nvoid main(void)\n{\n  v_texCoord = a_pos;\n  vec2 coord = u_drawPos + vec2(a_pos - 0.5) * vec2(u_width, u_height);\n  gl_Position = vec4(coord, 0.0, 1.0);\n}\n"},materials:{"constants.glsl":"const float C_DEG_TO_RAD = 3.14159265359 / 180.0;\nconst float SIGNED_BYTE_TO_UNSIGNED = 128.0;\n\n// markers\nconst float SOFT_EDGE_RATIO = 1.0; // use blur here if needed\n\n// lines\nconst float THIN_LINE_WIDTH_FACTOR = 1.1;\n\n// meaning that a 2 pixels line width is considered a thin line\nconst float THIN_LINE_HALF_WIDTH = 1.0;\n\n// labels \nconst float OFFSET_PRECISION = 1.0 / 8.0;\nconst float OUTLINE_SCALE = 1.0 / 5.0;\nconst float SDF_FONT_SIZE = 24.0;\n\n// maximum SDF distance of 8 pixels represent the distance values that range from -2 inside the\n// geometry to 6 on the outside. 6 is actually the maximum distance outside the glyph, therefore\n// it is the limitation of the halo which is 1/4 of the geometry size.\nconst float MAX_SDF_DISTANCE = 8.0;\n\nconst float PLACEMENT_PADDING = 8.0;\n\n\nconst float EPSILON = 0.0000001; \n\nconst int MAX_FILTER_COUNT = 2;\n","effects.glsl":"\nuniform mat4 u_insideEffectMat4[ MAX_FILTER_COUNT ];\nuniform mat4 u_outsideEffectMat4[ MAX_FILTER_COUNT ];\n\nvec4 getEffectColor(in vec4 color, in float filterFlags) {\n  vec4 outColor = vec4(color);\n\n  // default visibility filter is index 0, index 1+ are effects\n  for (int i = 1; i < EFFECT_COUNT + 1; i++) {\n    float bit = getBit(filterFlags, i);\n    \n    outColor = u_insideEffectMat4[ i ] * (bit  * outColor) + u_outsideEffectMat4[ i ] * ((1.0 - bit) * outColor);\n  }\n  \n  return outColor; \n}\n\nvoid applyFilter(inout vec4 color, inout vec3 pos, in float filterFlags) {\n\n  // default visibility filter is index 0, index 1+ are effects\n  for (int i = 0; i < EFFECT_COUNT + 1; i++) {\n    float bit = getBit(filterFlags, i); \n\n    color = u_insideEffectMat4[ i ] * (bit  * color) + u_outsideEffectMat4[ i ] * ((1.0 - bit) * color);\n  }\n\n  // If we are not visible, clip the vertex if we are doing a hit-test\n  pos.z += 2.0 * (1.0 - getBit(filterFlags, 0)); \n}\n\nvoid applyFilterLabels(inout vec4 color, inout vec3 pos, in float filterFlags) {\n  float bit = getBit(filterFlags, 0); \n\n  pos.z += 2.0 * (1.0 - bit);\n\n  // When outsideLabelsVisible is false, we also clip labels if they fail any effect filter\n#ifndef OUTSIDE_LABELS_VISIBLE\n  for (int i = 1; i < EFFECT_COUNT + 1; i++) {\n    float bit = getBit(filterFlags, i); \n\n    pos.z += 2.0 * (1.0 - bit);\n  }\n#endif\n}\n",fill:{"fill.frag":"precision highp float;\n\n#include <materials/constants.glsl>\n\n#ifdef ID\n\nvarying highp vec4 v_id;\n\n#endif // ID\n\n#ifdef PATTERN\n\nuniform lowp sampler2D u_texture;\n\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n\n#endif // PATTERN\n\n#ifdef DOT_DENSITY\n\nuniform mediump mat4 u_dotColors[ 2 ];\nuniform sampler2D u_dotTextures[ 2 ];\nuniform vec4 u_dotBackgroundColor;\n\nvarying highp vec4 v_dotThresholds[ 2 ];\nvarying vec2 v_dotTextureCoords;\n\n#endif\n\nvarying lowp vec4 v_color;\nvarying lowp float v_opacity;\n\nfloat max4(vec4 target) {\n  return max(max(max(target.x, target.y), target.z), target.w);\n}\n\nvoid main() {\n\n#ifdef ID\n\n  gl_FragColor = v_id;\n\n#elif defined(PATTERN)\n\n  // normalize the calculated texture coordinate such that it fits in the range of 0 to 1.\n  mediump vec2 normalizedTextureCoord = mod(v_tileTextureCoord, 1.0);\n  // interpolate the image coordinate between the top-left and the bottom right to get the actual position to sample.\n  // after normalizing the position, we get a value ranging between 0 and 1 which refers to the entire texture, however\n  // we need to only sample from area that has our sprite in the mosaic.\n  mediump vec2 samplePos = mix(v_tlbr.xy, v_tlbr.zw, normalizedTextureCoord);\n  // sample the sprite mosaic\n  lowp vec4 color = texture2D(u_texture, samplePos);\n  gl_FragColor = v_opacity * v_color * color;\n\n#elif defined(DOT_DENSITY) && !defined(HIGHLIGHT)\n\n  vec4 textureThresholds0 = texture2D(u_dotTextures[0], v_dotTextureCoords);\n  vec4 textureThresholds1 = texture2D(u_dotTextures[1], v_dotTextureCoords);\n\n  vec4 difference0 = v_dotThresholds[0] - textureThresholds0;\n  vec4 difference1 = v_dotThresholds[1] - textureThresholds1;\n\n#ifdef DD_DOT_BLENDING\n\n  vec4 isPositive0 = step(0.0, difference0);\n  vec4 isPositive1 = step(0.0, difference1);\n\n  float weightSum = dot(isPositive0, difference0) + dot(isPositive1, difference1);\n  float lessThanEqZero = step(weightSum, 0.0);\n  float greaterThanZero = 1.0 - lessThanEqZero ;\n  float divisor = (weightSum + lessThanEqZero); // Guard against divide by zero\n\n  vec4 weights0 = difference0 * isPositive0 / divisor;\n  vec4 weights1 = difference1 * isPositive1 / divisor;\n\n  vec4 dotColor = u_dotColors[0] * weights0 + u_dotColors[1] * weights1;\n\n  gl_FragColor = greaterThanZero * dotColor + lessThanEqZero * u_dotBackgroundColor;\n\n#else\n\n  float diffMax = max(max4(difference0), max4(difference1));\n  float lessThanZero = step(diffMax, 0.0);\n  float greaterOrEqZero = 1.0 - lessThanZero;\n\n  vec4 isMax0 = step(diffMax, difference0);\n  vec4 isMax1 = step(diffMax, difference1);\n\n  vec4 dotColor = u_dotColors[0] * isMax0 + u_dotColors[1] * isMax1;\n\n  gl_FragColor = greaterOrEqZero * dotColor + lessThanZero * u_dotBackgroundColor;\n\n#endif\n\n#else\n\n  gl_FragColor = v_opacity * v_color;\n\n#endif // PATTERN\n\n#ifdef HIGHLIGHT\n\n  gl_FragColor.a = 1.0;\n\n#endif // HIGHLIGHT\n}\n","fill.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;\nattribute vec4 a_id;                // objectId in RGBA components\nattribute float  a_visible;         // one byte controlling the visibility of the vertex (separate buffer),\n\n#ifndef DOT_DENSITY\nattribute vec4 a_color;\nattribute vec4 a_tlbr;\nattribute vec4 a_aux1;\nattribute vec2 a_aux2;\nattribute vec4 a_aux3;              // encodes a bitset (CIM) detailing vv locking\n#endif\n\n#if defined(VV_COLOR) || defined(VV_OPACITY)\nattribute highp vec4 a_vv;\n#endif\n\nuniform highp mat3 u_dvsMat3;      // premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\nuniform highp float u_pixelRatio;\n\nvarying lowp vec4 v_color;\nvarying lowp float v_opacity;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif\n\n#ifdef PATTERN\nuniform mediump float u_zoomFactor;\nuniform mediump vec2 u_mosaicSize;\n\nvarying mediump vec4 v_tlbr;\nvarying mediump vec2 v_tileTextureCoord;\n#endif\n\n#ifdef DOT_DENSITY\nattribute highp vec4 a_dd1;\nattribute highp vec4 a_dd2;\n\nuniform float u_dotValue;\nuniform float u_tileDotsOverArea; \n\nuniform float u_dotTextureDotCount;\nuniform float u_tileZoomFactor; \n\nvarying vec4 v_dotThresholds[ 2 ]; \nvarying vec2 v_dotTextureCoords;\n\nvec4 dotThreshold(vec4 featureAttrOverFeatureArea, float dotValue, float tileDotsOverArea) {\n  return featureAttrOverFeatureArea * (1.0 / dotValue)  * (1.0 / tileDotsOverArea);\n}\n#endif\n\nvoid main()\n{\n// Arguably DotDensity should be extracted to its own shader. This gets a bit\n// fungly because DD uses a signifcantly different stride\n#ifndef DOT_DENSITY \n  float a_bitset = a_aux3.w; \n  float isColorLocked = getBit(a_bitset, 0);\n  \n  v_color = a_color;\n#else\n  v_color = vec4(0.0, 0.0, 0.0, 1.0);    // for highlight\n#endif\n  v_opacity = 1.0;\n  \n#ifdef ID\n  v_id = a_id;\n#endif\n  \n#ifdef VV_OPACITY\n  v_opacity = getVVOpacity(a_vv.y);\n#endif\n  \n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.x, v_color, isColorLocked);\n#endif\n  \n#ifdef PATTERN\n  vec2 aux2 = (1.0 / SIGNED_BYTE_TO_UNSIGNED) * a_aux2;\n  vec2 symbolOffset = u_zoomFactor * (a_aux1.zw - SIGNED_BYTE_TO_UNSIGNED);\n  mat3 patternMatrix = mat3(1.0);\n\n  // calculate the pattern matrix\n  patternMatrix[0][0] = 1.0 / (u_zoomFactor * a_aux1.x * aux2.x);\n  patternMatrix[1][1] = 1.0 / (u_zoomFactor * a_aux1.y * aux2.y);\n\n  // calculate the texture coordinates of the current vertex. It will of course get interpolated.\n  // The pattern matrix is a 3x3 scale matrix which 'tiles' the texture inside the tile, translating from\n  // tile coordinates to texture coordinates.\n  v_tileTextureCoord = (patternMatrix * vec3(a_pos + symbolOffset, 1.0)).xy;\n  v_tlbr = a_tlbr / u_mosaicSize.xyxy;\n\n#elif defined(DOT_DENSITY)\n  float size = u_tileZoomFactor * 512.0 * 1.0 / u_pixelRatio;\n\n  v_dotThresholds[0] = dotThreshold(a_dd1, u_dotValue, u_tileDotsOverArea);\n  v_dotThresholds[1] = dotThreshold(a_dd2, u_dotValue, u_tileDotsOverArea);\n  v_dotTextureCoords = (a_pos + 0.5) / size;\n\n#endif\n  vec3 v_pos = u_dvsMat3 * vec3(a_pos, 1.);\n\n  applyFilter(v_color, v_pos, a_visible);\n  \n  gl_Position = vec4(v_pos, 1.0);\n}\n"},icon:{"icon.frag":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <util/encoding.glsl>\n#include <materials/effects.glsl>\n#include <materials/constants.glsl>\n\nuniform lowp sampler2D u_texture;\n\nvarying lowp vec2 v_tex;\nvarying lowp float v_transparency;\nvarying mediump vec2 v_size;\nvarying lowp vec4 v_color;\nvarying float v_visible;\n\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\nvarying float v_overridingOutlineColor;\n#endif // SDF\n\n#ifdef HIGHLIGHT\nvarying float v_isThinGeometry;\n#endif // HIGHLIGHT\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n#ifdef SDF\n  lowp vec4 fillPixelColor = v_color;\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  float d = 0.5 - rgba2float(texture2D(u_texture, v_tex));\n\n  // the soft edge ratio is about 1.5 pixels allocated for the soft edge.\n  float size = max(v_size.x, v_size.y);\n  float dist = d * size * SOFT_EDGE_RATIO;\n\n  // set the fragment's transparency according to the distance from the edge\n  fillPixelColor *= clamp(0.5 - dist, 0.0, 1.0);\n\n  float outlineWidth = v_outlineWidth;\n\n  #ifdef HIGHLIGHT\n    outlineWidth = max(outlineWidth, 4.0 * v_isThinGeometry);\n  #endif\n\n  // count for the outline\n  // therefore tint the entire icon area.\n  if (outlineWidth > 0.25) {\n    lowp vec4 outlinePixelColor = v_overridingOutlineColor * v_color + (1.0 - v_overridingOutlineColor) * v_outlineColor;\n\n    // outlines can't be larger than the size of the symbol\n    float clampedOutlineSize = min(outlineWidth, size);\n\n    outlinePixelColor *= clamp(0.5 - abs(dist) + clampedOutlineSize * 0.5, 0.0, 1.0);\n\n    // finally combine the outline and the fill colors (outline draws on top of fill)\n    gl_FragColor = v_transparency * ((1.0 - outlinePixelColor.a) * fillPixelColor + outlinePixelColor);\n  }\n  else {\n    gl_FragColor = v_transparency * fillPixelColor;\n  }\n#else // not an SDF\n   lowp vec4 texColor = texture2D(u_texture, v_tex);\n   gl_FragColor = v_transparency * getEffectColor(texColor, v_visible);\n#endif // SDF\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","icon.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;\nattribute vec4 a_vertexOffsetAndTex;\nattribute vec4 a_id;                   // objectId in RGBA components\nattribute vec4 a_color;\nattribute vec4 a_outlineColor;\nattribute vec4 a_sizeAndOutlineWidth;\nattribute float a_visible;             // one byte controlling the vertex visibility (separate buffer)\n\n#ifdef VV\nattribute highp vec4 a_vv;\n#endif\n\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3;\nuniform highp mat3 u_displayViewMat3;\nuniform vec2 u_mosaicSize;            // mosaic size in pixels\n\nvarying lowp vec4 v_color;\nvarying mediump vec2 v_tex;           // texture coordinates used to sample the sprite atlas\nvarying lowp float v_transparency;    // the calculated transparency to be applied by the fragment shader.\nvarying mediump vec2 v_size;          // icon size in px\nvarying float v_visible;\n\n#ifdef SDF\nvarying lowp vec4 v_outlineColor;\nvarying mediump float v_outlineWidth;\nvarying float v_overridingOutlineColor;\n#endif\n\n#ifdef HIGHLIGHT\nvarying float v_isThinGeometry;\n#endif // HIGHLIGHT\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif\n\nvec2 getMarkerSize(inout vec2 offset, in vec2 baseSize, in float vvSize) {\n  float f = getVVSize(baseSize.y, vvSize);\n  vec2 size = vec2(f * baseSize.x / baseSize.y, f);\n\n  offset *= (size / baseSize);\n  return size;\n}\n\nvoid main()\n{\n  vec2 offset = a_vertexOffsetAndTex.xy;\n  vec2 a_tex = a_vertexOffsetAndTex.zw + SIGNED_BYTE_TO_UNSIGNED;\n  vec2 a_size = a_sizeAndOutlineWidth.xy;\n  float a_bitset = a_sizeAndOutlineWidth.w;\n\n  float isMapAligned = getBit(a_bitset, 0);\n  float isColorLocked = getBit(a_bitset, 1);\n  float isThinGeometry = getBit(a_bitset, 2);\n  mat3 offsetMat3 = isMapAligned * u_displayViewMat3 + (1.0 - isMapAligned) * u_displayMat3;\n\n  v_transparency = 1.0;\n  v_color = a_color;\n  v_size = a_size;\n  v_tex = a_tex / u_mosaicSize; // texture coords and transparency\n  v_visible = a_visible;\n\n#ifdef ID\n  v_id = a_id;\n#endif\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#endif\n\n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.y, a_color, isColorLocked);\n#endif // VV_COLOR\n\n#ifdef VV_SIZE\n  v_size = getMarkerSize(offset, a_size, a_vv.x);\n#endif\n\n#ifdef VV_ROTATION\n  offset = (getVVRotationMat3(a_vv.w) * vec3(offset, 0.0)).xy;\n#endif\n\n#ifdef SDF\n  #ifdef VV_COLOR\n    // this is true only if we have SDF and color VV\n    v_overridingOutlineColor = isThinGeometry;\n  #else\n    v_overridingOutlineColor = 0.0;\n  #endif\n\n  offset *= 2.0;\n  v_outlineColor = getEffectColor(a_outlineColor, a_visible);\n  // YF: in practice v_size.x and v_size.y are identical since we're mostly dealing with sms\n  v_outlineWidth = min(a_sizeAndOutlineWidth.z, max(v_size.x - 0.99, 0.0));\n#endif\n\n#ifdef HIGHLIGHT\n  v_isThinGeometry = isThinGeometry;\n#endif\n\n  vec3 pos = u_dvsMat3 * vec3(a_pos, 1.0) + offsetMat3 * vec3(offset, 0.0);\n\n  applyFilter(v_color, pos, a_visible);\n\n  gl_Position = vec4(pos, 1.0);\n}\n"},label:{"label.frag":"precision lowp float;\n\nuniform mediump sampler2D u_referenceTex;\nuniform mediump vec2 u_screenSize;\nuniform mediump float u_pixelRatio;\n\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\n\n#ifdef ID\nvarying mediump float v_fadeStep;\n#else\nuniform lowp sampler2D u_texture;\nvarying mediump vec4 v_color;\n#endif // ID\n\nconst vec3 epsilon = vec3(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0);\n\nvoid main()\n{\n  mediump vec2 refTextPos = gl_FragCoord.xy / (u_pixelRatio * u_screenSize.xy);\n  mediump vec4 referenceFragment = texture2D(u_referenceTex, refTextPos);\n#ifdef ID\n  mediump float alpha = clamp(referenceFragment.a + v_fadeStep, 0.0, 1.0);\n  // fill the whole quad\n  gl_FragColor = vec4(alpha);\n#else\n  // read the fade alpha\n  lowp float fadeAlpha = referenceFragment.a;\n\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // the edge distance if a factor of the outline width\n  // We cap this to 0.25 to prevent this from becomming negative / running into the glyph boundaries\n  float glyphEdgeDistance = max(0.75 - v_edgeDistanceOffset, 0.25);\n\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  lowp float sdfAlpha = smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist);\n\n  gl_FragColor = fadeAlpha * sdfAlpha * v_color;\n#endif\n}\n","label.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;                         // (2 x i16)\nattribute vec4 a_color;                       // (4 x u8)\nattribute vec2 a_vertexOffset;                // (2 x i16) offset from the anchor point of the string\nattribute vec4 a_texAndSize;                  // (4 x u8) texture coordinatesm and font size. w is for the halo size\nattribute vec4 a_refSymbolAndPlacementOffset; // (4 x u8) reference symbol offset (px) and the placement offset (px)\nattribute float a_vvSize;                     // size visual variable\nattribute lowp float  a_visible;              // a one byte controlling the visibility of the vertex (separate buffer)\nattribute mediump vec2 a_visibilityRange;     // (2 x u8);\n\nuniform mediump float u_zoomLevel;            // the current zoom level X 10\nuniform highp mat3 u_dvsMat3;                 // premultiplies displayMat3 * viewMat3 * screenMat3\nuniform highp mat3 u_displayMat3;\nuniform float u_mapRotation;\nuniform float u_mapAligned;\nuniform vec2 u_mosaicSize;\nuniform float u_pixelRatio;\n\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;                   // texture coordinates used to sample the glyph atlas\nvarying mediump vec4 v_color;\n\n#ifdef ID                                     // somewhat of a misnomer - id is used here for the label alpha phase\nuniform mediump float u_fadeStep; \nvarying mediump float v_fadeStep;\n#endif\n\nfloat getZ(in float minZoom, in float maxZoom, in float angle) {\n  float glyphAngle = angle * 360.0 / 254.0;\n  float mapAngle = u_mapRotation * 360.0 / 254.0;\n  float diffAngle = min(360.0 - abs(mapAngle - glyphAngle), abs(mapAngle - glyphAngle));\n  float z = 0.0;\n\n  // make sure range is inclusive\n  z += 2.0 * (1.0 - step(minZoom, u_zoomLevel));\n  z += 2.0 * (1.0 - step(u_zoomLevel, maxZoom));\n  z += 2.0 * u_mapAligned * step(90.0, diffAngle);\n  return z;\n}\n\nvoid main()\n{\n  float isHalo = mod(a_pos, 2.0).x; // lsb of a_pos denotes whether a vertex is part of the halo or not\n  vec3 pos = vec3(floor(a_pos * 0.5), 1.0);\n  vec2 placementDir = a_refSymbolAndPlacementOffset.zw - 1.0;  // encoded as dir + 1.0\n  vec2 vertexOffset = a_vertexOffset * OFFSET_PRECISION;\n  float refSymbolSize = a_refSymbolAndPlacementOffset.y;\n  float fontSize = a_texAndSize.z;\n  float z = getZ(a_visibilityRange.x, a_visibilityRange.y, a_refSymbolAndPlacementOffset.x);\n\n  float fontScale = fontSize / SDF_FONT_SIZE;\n  float halfSize = refSymbolSize / 2.0;\n\n  v_color = a_color;\n  v_tex = a_texAndSize.xy / u_mosaicSize;\n\n#ifdef ID\n  v_fadeStep = u_fadeStep;\n#endif\n  \n#ifdef VV_SIZE // unlike with text, this is the VV_SIZE of the reference symbol, not the label itself\n  halfSize = getVVSize(refSymbolSize, a_vvSize) / 2.0;\n#endif\n  // if halo.x is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\n  v_edgeDistanceOffset = isHalo * OUTLINE_SCALE * a_texAndSize.w / fontScale / MAX_SDF_DISTANCE;\n  v_antialiasingWidth = 0.106 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\n\n  vec2 placementOffset = placementDir * (halfSize + PLACEMENT_PADDING);\n  vec3 glyphOffset = u_displayMat3 * vec3(vertexOffset + placementOffset, 0.0);\n  vec3 v_pos = u_dvsMat3 * pos + glyphOffset;\n  \n  applyFilterLabels(v_color, v_pos, a_visible);\n\n#ifdef DEBUG\n  v_color = vec4(a_color.rgb, z == 0.0 ? 1.0 : 0.645);  // visualize hidden glyphs\n#endif\n  \n  gl_Position = vec4(v_pos.xy, v_pos.z + z, 1.0);\n}\n"},line:{"line.frag":"precision lowp float;\n\n#include <util/encoding.glsl>\n#include <materials/constants.glsl>\n\nuniform lowp float u_blur;\nuniform mediump float u_antialiasing;\n\nvarying mediump vec2 v_normal;\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying lowp float v_transparency;\n\n#if defined(PATTERN) || defined(SDF)\nuniform sampler2D u_texture;\nuniform mediump float u_zoomFactor;\n\nvarying mediump vec4 v_tlbr; // normalized pattern coordinates [0, 1]\nvarying mediump vec2 v_patternSize;\nvarying highp float v_accumulatedDistance;\n#endif // PATTERN SDF\n\n#ifdef SDF\nconst float sdfPatternHalfWidth = 15.5; // YF: assumed that the width will be set to 31\nconst float widthFactor = 2.0;\n#endif // SDF\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\n\nvoid main()\n{\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides of the centerline)\n  mediump float thinLineFactor = max(THIN_LINE_WIDTH_FACTOR * step(v_lineHalfWidth, THIN_LINE_HALF_WIDTH), 1.0);\n\n  // dist represent the distance of the fragment from the line. 1.0 or -1.0 will be the values on the edge of the line,\n  // and any value in between will be inside the line (the sign represent the direction - right or left).\n  // since u_linewidth.s (half line width) is represented in pixels, dist is also given in pixels\n  mediump float fragDist = length(v_normal) * v_lineHalfWidth;\n\n  // calculate the alpha given the difference between the line-width and the distance of the fragment from the center-line.\n  // when it is a thin line then use a slightly shallower slope in order to add more feathering\n  lowp float alpha = clamp(thinLineFactor * (v_lineHalfWidth - fragDist) / (u_blur + thinLineFactor - 1.0), 0.0, 1.0);\n\n#if defined(SDF) && !defined(HIGHLIGHT) // When we render the highlight, we want to treat the line as if it was solid\n  mediump float lineHalfWidth = widthFactor * v_lineHalfWidth;\n  mediump float lineWidthRatio = lineHalfWidth / sdfPatternHalfWidth;\n  mediump float relativeTexX = mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * lineHalfWidth) / (lineWidthRatio * v_patternSize.x), 1.0);\n  mediump float relativeTexY = 0.5 + 0.5 * v_normal.y;\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\n\n  // calculate the distance from the edge [-0.5, 0.5]\n  mediump float d = rgba2float(texture2D(u_texture, texCoord)) - 0.5;\n\n  // the distance is a proportional to the line width\n  float dist = d * lineHalfWidth;\n\n  lowp vec4 fillPixelColor = v_transparency * alpha * clamp(0.5 - dist, 0.0, 1.0) * v_color;\n  gl_FragColor = fillPixelColor;\n#elif defined(PATTERN) && !defined(HIGHLIGHT)  // When we render the highlight, we want to treat the line as if it was solid\n  // we need to calculate the relative portion of the line texture along the line given the accumulated distance along the line\n  // The computed value should is anumber btween 0 and 1 which will later be used to interpolate btween the BR and TL values\n  mediump float relativeTexX = mod((u_zoomFactor * v_accumulatedDistance + v_normal.x * v_lineHalfWidth) / v_patternSize.x, 1.0);\n\n  // in order to calculate the texture coordinates prependicular to the line (Y axis), we use the interpolated normal values\n  // which range from -1.0 to 1.0. On the line's centerline, the value of the interpolated normal is 0.0, however the relative\n  // texture value shpould be 0.5 (given that at the bottom of the line, the texture coordinate must be equal to 0.0)\n  // (TL) ---------------------------      --\x3e left edge of line. Interpolatedf normal is 1.0\n  //              | -> line-width / 2\n  //      - - - - - - - - - - - - - -\n  //              | -> line-width / 2\n  //      ---------------------------- (BR)--\x3e right edge of line. Interpolatedf normal is -1.0\n\n  mediump float relativeTexY = 0.5 + (v_normal.y * v_lineHalfWidth / v_patternSize.y);\n\n  // claculate the actual texture coordinates by interpolating between the TL/BR pattern coordinates\n  mediump vec2 texCoord = mix(v_tlbr.xy, v_tlbr.zw, vec2(relativeTexX, relativeTexY));\n\n  // get the color from the texture\n  lowp vec4 color = texture2D(u_texture, texCoord);\n\n  gl_FragColor = v_transparency * alpha * v_color * color;\n#else // solid line (no texture, no pattern)\n  // output the fragment color\n  gl_FragColor = v_transparency * alpha * v_color;\n#endif // SDF\n\n#ifdef HIGHLIGHT\n  gl_FragColor.a = step(1.0 / 255.0, gl_FragColor.a);\n#endif // HIGHLIGHT\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","line.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;\nattribute vec4 a_id;\nattribute vec4 a_color;\nattribute vec4 a_offsetAndNormal;\nattribute vec2 a_accumulatedDistanceAndHalfWidth;\nattribute vec4 a_tlbr;\nattribute vec4 a_segmentDirection;\nattribute float  a_visible;                // a one byte controlling the visibility of the vertex (separate buffer)\n\n#ifdef VV\nattribute highp vec3 a_vv;\n#endif\n\nuniform highp mat3 u_dvsMat3;              // premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\nuniform highp mat3 u_displayViewMat3;     // premultiplies DisplayMat3 * ViewMat3\nuniform mediump float u_zoomFactor;\nuniform mediump float u_antialiasing;\n\nvarying mediump vec2 v_normal;             // interpolated normal to the line. packed into the two LSBs of the vertex coordinate\nvarying mediump float v_lineHalfWidth;\nvarying lowp vec4 v_color;\nvarying lowp float v_transparency;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif\n\n#ifdef PATTERN\nuniform mediump vec2 u_mosaicSize;\n\nvarying mediump vec4 v_tlbr;               // normalized pattern coordinates [0, 1]\nvarying mediump vec2 v_patternSize;\n#endif\n\n#if defined(PATTERN) || defined(SDF)\nvarying highp float v_accumulatedDistance; // we need to accumulated distance only if it is a pattern or an SDF line\n#endif\n\n#if defined(SDF) && !defined(HIGHLIGHT) // When we render the highlight, we want to treat the line as if it was solid\nconst float widthFactor = 2.0;\n#else\nconst float widthFactor = 1.0;\n#endif\n\nconst float scale = 1.0 / 31.0;\n\nvoid main()\n{\n  float a_bitset = a_segmentDirection.w;\n\n  float isColorLocked = getBit(a_bitset, 0);\n  float lineHalfWidth = a_accumulatedDistanceAndHalfWidth.y * scale;\n\n  v_transparency = 1.0;\n  v_color = a_color;\n  v_normal = a_offsetAndNormal.zw * scale;\n\n#ifdef ID\n  v_id = a_id;\n#endif\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#endif\n\n#ifdef VV_COLOR\n  v_color = getVVColor(a_vv.y, v_color, isColorLocked);\n#endif\n\n#ifdef VV_SIZE\n  lineHalfWidth = 0.5 * getVVSize(2.0 * lineHalfWidth, a_vv.x);\n#endif\n\n#ifdef PATTERN\n  v_tlbr = a_tlbr / u_mosaicSize.xyxy;\n  v_patternSize = vec2(a_tlbr.z - a_tlbr.x, a_tlbr.w - a_tlbr.y);\n#endif\n\n  // make sure to clip the vertices in case that the width of the line is 0 (or negative)\n  float z = 2.0 * step(lineHalfWidth, 0.0);\n\n  // add an antialiasing distance. We use 0.2 rather than 0.5 in order to match the SVG renderer\n  // also limit the total line width to 1.3 pixels. Below this value lines don't look good compared\n  // to the SVG renderer\n  v_lineHalfWidth = max(lineHalfWidth, 0.45) + 0.2 * u_antialiasing;\n\n\n#ifdef HIGHLIGHT\n  v_lineHalfWidth = max(v_lineHalfWidth, 2.0);\n#endif\n\n  // for now assume that a thin line is a line which is under 2 pixels (1 pixels on either sides\n  // of the centerline) in practice, a thin line is a line who's half width vary from 0.45px to\n  // the value of thinLineHalfWidth, as the value is claped in line 221 above\n  mediump float thinLineFactor = max(THIN_LINE_WIDTH_FACTOR * step(v_lineHalfWidth, THIN_LINE_HALF_WIDTH), 1.0);\n\n  // calculate the relative distance from the centerline to the edge of the line. Since offset is\n  // given in integers (for the sake of using less attribute memory, we need to scale it back to\n  // the original range of ~ [0, 1]) in a case of a thin line we move each vertex twice as far\n  mediump vec2 dist = thinLineFactor * widthFactor * v_lineHalfWidth * a_offsetAndNormal.xy * scale;\n\n#if defined(PATTERN) || defined(SDF)\n  v_accumulatedDistance = a_accumulatedDistanceAndHalfWidth.x + dot(scale * a_segmentDirection.xy, dist / u_zoomFactor);\n#endif\n\n  vec3 offset = u_displayViewMat3 * vec3(dist, 0.0);\n  vec3 v_pos = u_dvsMat3 * vec3(a_pos.xy, 1.0) + offset;\n  vec3 pos = vec3(v_pos.xy, z);\n\n  applyFilter(v_color, pos, a_visible);\n\n  gl_Position = vec4(pos, 1.0);\n}\n"},text:{"text.frag":"precision lowp float;\n\nuniform lowp sampler2D u_texture;\n\nvarying mediump vec4 v_color;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;\nvarying lowp float v_transparency;\n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  // read the distance from the SDF texture\n  lowp float dist = texture2D(u_texture, v_tex).a;\n\n  // the edge distance if a factor of the outline width\n  // We cap this to 0.25 to prevent this from becomming negative / running into the glyph boundaries\n  float glyphEdgeDistance = max(0.75 - v_edgeDistanceOffset, 0.25);\n\n  #ifdef HIGHLIGHT\n    glyphEdgeDistance /= 2.0;\n  #endif\n\n  // use a smooth-step in order to calculate the geometry of the shape given by the distance field\n  lowp float alpha = smoothstep(glyphEdgeDistance - v_antialiasingWidth, glyphEdgeDistance + v_antialiasingWidth, dist) * v_transparency;\n\n  gl_FragColor = alpha * v_color;\n\n#ifdef ID\n  if (gl_FragColor.a < 1.0 / 255.0) {\n    discard;\n  }\n  gl_FragColor = v_id;\n#endif // ID\n}\n","text.vert":"precision mediump float;\n\n#include <materials/constants.glsl>\n#include <materials/utils.glsl>\n#include <materials/vv.glsl>\n#include <materials/effects.glsl>\n\nattribute vec2 a_pos;          // 2 * 2 (2 x signed 16)\nattribute vec4 a_id;           // 4 (4 x unsigned byte)\nattribute vec4 a_color;        // 4 (4 x unsigned byte)\nattribute vec2 a_vertexOffset; // 2 * 2 // (2 x signed 16) offset from the anchor point of the string\nattribute vec4 a_texFontSize;  // 4 (4 x unsigned byte) texture coordinatesm and font size\nattribute vec4 a_aux;          // hold onto additional information such as a bitset on the last byte (a_aux.w)\nattribute float a_visible;     // a one byte controlling the visibility of the vertex (a separate visibility buffer)\n\n#ifdef VV\nattribute highp vec4 a_vv;\n#endif\n\nuniform vec2 u_mosaicSize;\nuniform float u_pixelRatio;\nuniform highp mat3 u_dvsMat3;\nuniform highp mat3 u_displayMat3; // Premultiplies DisplayMat3 * ViewMat3 * ScreenMat3\n\nvarying mediump vec4 v_color;\nvarying mediump float v_antialiasingWidth;\nvarying mediump float v_edgeDistanceOffset;\nvarying mediump vec2 v_tex;        // texture coordinates used to sample the glyph atlas\nvarying lowp float v_transparency; // the calculated transparency to be applied by the fragment shader. \n\n#ifdef ID\nvarying highp vec4 v_id;\n#endif // ID\n\nvoid main()\n{\n  float a_bitset = a_aux.w;\n\n  float isColorLocked = getBit(a_bitset, 0);\n  float isHalo = getBit(a_pos.x, 0);   // The lsb of pos denotes whether a vertex is part of the halo or not\n  float fontSize = a_texFontSize.z;\n  vec3 pos = vec3(floor(a_pos * 0.5), 1.0);\n  vec3 offset = vec3(a_vertexOffset * OFFSET_PRECISION, 0.0);\n  float scale = 1.0;\n\n  v_transparency = 1.0;\n  v_color = a_color;\n  v_tex = a_texFontSize.xy / u_mosaicSize;\n\n#ifdef ID\n  v_id = a_id;\n#endif\n\n#ifdef VV_OPACITY\n  v_transparency = getVVOpacity(a_vv.z);\n#endif\n\n#ifdef VV_COLOR\n  // we don't want to override the halo color\n  v_color = isHalo * a_color + (1.0 - isHalo) * getVVColor(a_vv.y, a_color, isColorLocked);\n#endif\n\n#ifdef VV_SIZE\n  float f = getVVSize(a_texFontSize.z, a_vv.x);\n  scale = f / fontSize; \n  fontSize = f;\n  offset.xy *= scale; \n#endif\n  \n#ifdef VV_ROTATION\n  offset = getVVRotationMat3(a_vv.w) * offset;\n#endif\n\n  vec3 v_pos = u_dvsMat3 * pos + u_displayMat3 * offset;\n  float fontScale = fontSize / SDF_FONT_SIZE;\n\n  // if isHalo is zero (not a halo) v_edgeDistanceOffset will end up being zero as well.\n  v_edgeDistanceOffset = isHalo * OUTLINE_SCALE * a_texFontSize.w / fontScale / MAX_SDF_DISTANCE;\n  v_antialiasingWidth = 0.105 * SDF_FONT_SIZE / fontSize / u_pixelRatio;\n\n  applyFilter(v_color, v_pos, a_visible);\n  \n  gl_Position = vec4(v_pos, 1.0);\n}\n"},"utils.glsl":"\nfloat getBit(in float bitset, in int bitIndex) {\n  float offset = pow(2.0, float(bitIndex));\n\n  return mod(floor(bitset / offset), 2.0);\n}\n","vv.glsl":"#if defined(VV_SIZE_MIN_MAX_VALUE) || defined(VV_SIZE_SCALE_STOPS) || defined(VV_SIZE_FIELD_STOPS) || defined(VV_SIZE_UNIT_VALUE)\n  #define VV_SIZE\n#endif\n\n#if defined(VV_COLOR) || defined(VV_SIZE) || defined(VV_OPACITY) || defined(VV_ROTATION)\n  #define VV\n#endif\n\n#ifdef VV_COLOR\nuniform highp float u_vvColorValues[8];\nuniform vec4 u_vvColors[8];\n#endif // VV_COLOR\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nuniform highp vec4 u_vvSizeMinMaxValue;\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_SCALE_STOPS\nuniform highp float u_vvSizeScaleStopsValue;\n#endif // VV_SIZE_SCALE_STOPS\n\n#ifdef VV_SIZE_FIELD_STOPS\nuniform highp float u_vvSizeFieldStopsValues[6];\nuniform float u_vvSizeFieldStopsSizes[6];\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nuniform highp float u_vvSizeUnitValueWorldToPixelsRatio;\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nuniform highp float u_vvOpacityValues[8];\nuniform float u_vvOpacities[8];\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nuniform lowp float u_vvRotationType;\n#endif // VV_ROTATION\n\nconst highp float nanValue = 1e-30;\n\nbool isNan(float val) {\n  return (val == nanValue);\n  //return !( val < 0.0 || 0.0 < val || val == 0.0 );\n}\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\nfloat getVVMinMaxSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  // we need to multiply by 8 in order to translate to tile coordinates\n  float interpolationRatio = (sizeValue  - u_vvSizeMinMaxValue.x) / (u_vvSizeMinMaxValue.y - u_vvSizeMinMaxValue.x);\n  interpolationRatio = clamp(interpolationRatio, 0.0, 1.0);\n  return u_vvSizeMinMaxValue.z + interpolationRatio * (u_vvSizeMinMaxValue.w - u_vvSizeMinMaxValue.z);\n}\n#endif // VV_SIZE_MIN_MAX_VALUE\n\n#ifdef VV_SIZE_FIELD_STOPS\nconst int VV_SIZE_N = 6;\nfloat getVVStopsSize(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  if (sizeValue <= u_vvSizeFieldStopsValues[0]) {\n    return u_vvSizeFieldStopsSizes[0];\n  }\n\n  for (int i = 1; i < VV_SIZE_N; ++i) {\n    if (u_vvSizeFieldStopsValues[i] >= sizeValue) {\n      float f = (sizeValue - u_vvSizeFieldStopsValues[i-1]) / (u_vvSizeFieldStopsValues[i] - u_vvSizeFieldStopsValues[i-1]);\n      return mix(u_vvSizeFieldStopsSizes[i-1], u_vvSizeFieldStopsSizes[i], f);\n    }\n  }\n\n  return u_vvSizeFieldStopsSizes[VV_SIZE_N - 1];\n}\n#endif // VV_SIZE_FIELD_STOPS\n\n#ifdef VV_SIZE_UNIT_VALUE\nfloat getVVUnitValue(float sizeValue, float fallback) {\n  if (isNan(sizeValue)) {\n    return fallback;\n  }\n\n  return u_vvSizeUnitValueWorldToPixelsRatio * sizeValue;\n}\n#endif // VV_SIZE_UNIT_VALUE\n\n#ifdef VV_OPACITY\nconst int VV_OPACITY_N = 8;\nfloat getVVOpacity(float opacityValue) {\n  if (isNan(opacityValue)) {\n    return 1.0;\n  }\n\n  if (opacityValue <= u_vvOpacityValues[0]) {\n    return u_vvOpacities[0];\n  }\n\n  for (int i = 1; i < VV_OPACITY_N; ++i) {\n    if (u_vvOpacityValues[i] >= opacityValue) {\n      float f = (opacityValue - u_vvOpacityValues[i-1]) / (u_vvOpacityValues[i] - u_vvOpacityValues[i-1]);\n      return mix(u_vvOpacities[i-1], u_vvOpacities[i], f);\n    }\n  }\n\n  return u_vvOpacities[VV_OPACITY_N - 1];\n}\n#endif // VV_OPACITY\n\n#ifdef VV_ROTATION\nmat4 getVVRotation(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat4(1, 0, 0, 0,\n                0, 1, 0, 0,\n                0, 0, 1, 0,\n                0, 0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat4(cosA, sinA, 0, 0,\n              -sinA,  cosA, 0, 0,\n              0,     0, 1, 0,\n              0,     0, 0, 1);\n}\n\nmat3 getVVRotationMat3(float rotationValue) {\n  // YF TODO: if the symbol has rotation we need to combine the symbo's rotation with the VV one\n  if (isNan(rotationValue)) {\n    return mat3(1, 0, 0,\n                0, 1, 0,\n                0, 0, 1);\n  }\n\n  float rotation = rotationValue;\n  if (u_vvRotationType == 1.0) {\n    rotation = 90.0 - rotation;\n  }\n\n  float angle = C_DEG_TO_RAD * -rotation;\n\n  float sinA = sin(angle);\n  float cosA = cos(angle);\n\n  return mat3(cosA, -sinA, 0,\n             sinA, cosA, 0,\n              0,    0,    1);\n}\n#endif // VV_ROTATION\n\n#ifdef VV_COLOR\nconst int VV_COLOR_N = 8;\n\nvec4 getVVColor(float colorValue, vec4 fallback, float isColorLocked) {\n  if (isNan(colorValue) || isColorLocked == 1.0) {\n    return fallback;\n  }\n\n  if (colorValue <= u_vvColorValues[0]) {\n    return u_vvColors[0];\n  }\n\n  for (int i = 1; i < VV_COLOR_N; ++i) {\n    if (u_vvColorValues[i] >= colorValue) {\n      float f = (colorValue - u_vvColorValues[i-1]) / (u_vvColorValues[i] - u_vvColorValues[i-1]);\n      return mix(u_vvColors[i-1], u_vvColors[i], f);\n    }\n  }\n\n  return u_vvColors[VV_COLOR_N - 1];\n}\n#endif // VV_COLOR\n\nfloat getVVSize(in float size, in float vvSize)  {\n\n#ifdef VV_SIZE_MIN_MAX_VALUE\n  return getVVMinMaxSize(vvSize, size);\n\n#elif defined(VV_SIZE_SCALE_STOPS)\n  return u_vvSizeScaleStopsValue;\n\n#elif defined(VV_SIZE_FIELD_STOPS)\n  return getVVStopsSize(vvSize, size);\n\n#elif defined(VV_SIZE_UNIT_VALUE)\n  return getVVUnitValue(vvSize, size);\n\n#else\n  return size;\n\n#endif\n}\n"},raster:{"solid.frag":"precision mediump float;\n\nvoid main(void) {\n  gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n}\n","texture.frag":"precision mediump float;\n\n// Texture coordinates.\nvarying vec2 v_texcoord;\n\n// Texture sampler.\nuniform sampler2D u_texture;\n\n// Opacity.\nuniform float u_opacity;\n\nvoid main(void) {\n  vec4 color = texture2D(u_texture, v_texcoord);\n  color.a *= u_opacity;\n  gl_FragColor = vec4(color.rgb * color.a, color.a);\n}\n","transform.vert":"precision mediump float;\n\n// Vertex position. Assumed normalized in the [0, 1] range.\nattribute vec2 a_position;\n\n// Transform matrix.\nuniform mat4 u_transform;\n\n// Output texture coordinates, for interpolation.\nvarying vec2 v_texcoord;\n\nvoid main(void) {\n  gl_Position = u_transform * vec4((2.0 * a_position - 1.0), 0.0, 1.0);\n  v_texcoord = a_position;\n}\n"},stencil:{"stencil.frag":"void main() {\n  gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n}\n","stencil.vert":"attribute vec2 a_pos;\n\nvoid main() {\n  gl_Position = vec4(a_pos, 0.0, 1.0);\n}\n"},tileInfo:{"tileInfo.frag":"uniform mediump sampler2D u_texture;\nvarying mediump vec2 v_tex;\n\nvoid main(void) {\n  lowp vec4 color = texture2D(u_texture, v_tex);\n  gl_FragColor = 0.75 * color;\n}\n","tileInfo.vert":"attribute vec2 a_pos;\n\nuniform highp mat3 u_dvsMat3;\n\nuniform mediump float u_depth;\nuniform mediump float u_coord_ratio;\nuniform mediump vec2 u_delta; // in tile coordinates\nuniform mediump vec2 u_dimensions; // in tile coordinates\n\nvarying mediump vec2 v_tex;\n\nvoid main() {\n  mediump vec2 offset = u_coord_ratio * vec2(u_delta + a_pos * u_dimensions);\n  vec3 v_pos = u_dvsMat3 * vec3(offset, 1.0);\n  \n  gl_Position = vec4(v_pos.xy, 0.0, 1.0);\n\n  v_tex = a_pos;\n}\n"},util:{"encoding.glsl":"// Factors to convert rgba back to float\nconst vec4 rgba2float_factors = vec4(\n    255.0 / (256.0),\n    255.0 / (256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0),\n    255.0 / (256.0 * 256.0 * 256.0 * 256.0)\n  );\n\nfloat rgba2float(vec4 rgba) {\n  // Convert components from 0->1 back to 0->255 and then\n  // add the components together with their corresponding\n  // fixed point factors, i.e. (256^1, 256^2, 256^3, 256^4)\n  return dot(rgba, rgba2float_factors);\n}\n"}}}.apply(null,n))||(e.exports=r)},VyQn:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("7ha9"),i("suZm")],void 0===(r=function(e,t,i,n){return function(){function e(e){this._iconRenderer=new i(e),this._sdfRenderer=new n(e)}return e.prototype.dispose=function(){this._iconRenderer&&(this._iconRenderer.dispose(),this._iconRenderer=null),this._sdfRenderer&&(this._sdfRenderer.dispose(),this._sdfRenderer=null)},e.prototype.render=function(e,t,i,n,r,a,o,s,l,d,u,c,f,h){t.hasData()&&(t.markerPerPageElementsMap.size>0&&this._iconRenderer.render(e,t,i,n,r,a,o,s,l,u,c,h),t.glyphPerPageElementsMap.size>0&&this._sdfRenderer.render(e,t,i,n,r,a,o,s,d,u,c,f,h))},e}()}.apply(null,n))||(e.exports=r)},Zp3t:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("H1tY")],void 0===(r=function(e,t,i){function n(e){return null!=e&&"type"in e&&"compressed"===e.type}return function(){function e(t,n,r){this._context=null,this._glName=null,this._id=-1,this._desc=void 0,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._boundToUnits=new Set,this._context=t,this._desc={pixelFormat:n.pixelFormat,internalFormat:n.internalFormat,dataType:n.dataType,target:n.target?n.target:3553,samplingMode:n.samplingMode?n.samplingMode:9729,wrapMode:n.wrapMode?n.wrapMode:10497,maxAnisotropy:n.maxAnisotropy,flipped:void 0!==n.flipped&&n.flipped,hasMipmap:void 0!==n.hasMipmap&&n.hasMipmap,unpackAlignment:n.unpackAlignment?n.unpackAlignment:4,width:n.width,height:n.height,preMultiplyAlpha:void 0!==n.preMultiplyAlpha&&n.preMultiplyAlpha,textureCoordinateScaleFactor:n.textureCoordinateScaleFactor||null},this._id=++e._nextId,i("esri-webgl-debug")&&t.instanceCounter.incrementCount(0),this.setData(r)}return Object.defineProperty(e.prototype,"id",{get:function(){return this._id},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"glName",{get:function(){return this._glName},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"descriptor",{get:function(){return this._desc},enumerable:!0,configurable:!0}),e.prototype.dispose=function(){var e=this;if(this._context){if(this._glName){var t=this._context.gl;this._boundToUnits.forEach(function(t){e._context.bindTexture(null,t)}),t.deleteTexture(this._glName),this._glName=null}i("esri-webgl-debug")&&this._context.instanceCounter.decrementCount(0),this._context=null}},e.prototype.resize=function(e,t){var i=this._desc;i.width===e&&i.height===t||(i.width=e,i.height=t,this.setData(null))},e.prototype.setData=function(t){var i=this._context.gl;this._glName||(this._glName=i.createTexture()),void 0===t&&(t=null),null===t&&(this._desc.width=this._desc.width||4,this._desc.height=this._desc.height||4);var r=this._context.getBoundTexture(0);this._context.bindTexture(this,0);var a=this._desc;e._validateTexture(a),i.pixelStorei(i.UNPACK_ALIGNMENT,a.unpackAlignment),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,a.flipped?1:0),i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL,a.preMultiplyAlpha?1:0);var o=a.pixelFormat,s=a.internalFormat?a.internalFormat:o;if(t instanceof ImageData||t instanceof HTMLImageElement||t instanceof HTMLCanvasElement||t instanceof HTMLVideoElement)a.width&&a.height,i.texImage2D(i.TEXTURE_2D,0,s,o,a.dataType,t),a.hasMipmap&&this.generateMipmap(),void 0===this._desc.width&&(this._desc.width=t.width),void 0===this._desc.height&&(this._desc.height=t.height);else{null!=a.width&&a.height,i.DEPTH24_STENCIL8&&s===i.DEPTH_STENCIL&&(s=i.DEPTH24_STENCIL8);var l=a.width,d=a.height;if(n(t)){var u=Math.round(Math.log(Math.max(l,d))/Math.LN2)+1;a.hasMipmap=a.hasMipmap&&u===t.levels.length;for(var c=0;;++c){var f=t.levels[Math.min(c,t.levels.length-1)];if(i.compressedTexImage2D(i.TEXTURE_2D,c,s,l,d,0,f),1===l&&1===d||!a.hasMipmap)break;l=Math.max(1,l>>1),d=Math.max(1,d>>1)}}else if(t)i.texImage2D(i.TEXTURE_2D,0,s,l,d,0,o,a.dataType,t),a.hasMipmap&&this.generateMipmap();else for(c=0;i.texImage2D(i.TEXTURE_2D,c,s,l,d,0,o,a.dataType,null),(1!==l||1!==d)&&a.hasMipmap;++c)l=Math.max(1,l>>1),d=Math.max(1,d>>1)}e._applySamplingMode(i,this._desc),e._applyWrapMode(i,this._desc),e._applyAnisotropicFilteringParameters(this._context,this._desc),this._context.bindTexture(r,0)},e.prototype.updateData=function(e,t,i,n,r,a){this._glName;var o=this._context.gl,s=this._desc,l=this._context.getBoundTexture(0);this._context.bindTexture(this,0),t<0||i<0||n>s.width||r>s.height||t+n>s.width||s.height,a instanceof ImageData||a instanceof HTMLImageElement||a instanceof HTMLCanvasElement||a instanceof HTMLVideoElement?o.texSubImage2D(o.TEXTURE_2D,e,t,i,s.pixelFormat,s.dataType,a):o.texSubImage2D(o.TEXTURE_2D,e,t,i,n,r,s.pixelFormat,s.dataType,a),this._context.bindTexture(l,0)},e.prototype.generateMipmap=function(){var t=this._desc;t.hasMipmap||(t.hasMipmap=!0,e._validateTexture(t)),9729===t.samplingMode?(this._samplingModeDirty=!0,t.samplingMode=9985):9728===t.samplingMode&&(this._samplingModeDirty=!0,t.samplingMode=9984);var i=this._context.getBoundTexture(0);this._context.bindTexture(this,0);var n=this._context.gl;n.generateMipmap(n.TEXTURE_2D),this._context.bindTexture(i,0)},e.prototype.setSamplingMode=function(t){t!==this._desc.samplingMode&&(this._desc.samplingMode=t,e._validateTexture(this._desc),this._samplingModeDirty=!0)},e.prototype.setWrapMode=function(t){t!==this._desc.wrapMode&&(this._desc.wrapMode=t,e._validateTexture(this._desc),this._wrapModeDirty=!0)},e.prototype.applyChanges=function(){var t=this._context.gl,i=this._desc;this._samplingModeDirty&&(e._applySamplingMode(t,i),this._samplingModeDirty=!1),this._wrapModeDirty&&(e._applyWrapMode(t,i),this._wrapModeDirty=!1)},e.prototype.setBoundToUnit=function(e,t){t?this._boundToUnits.add(e):this._boundToUnits.delete(e)},e._isPowerOfTwo=function(e){return 0==(e&e-1)},e._validateTexture=function(t){t.width<0||t.height,e._isPowerOfTwo(t.width)&&e._isPowerOfTwo(t.height)||("number"==typeof t.wrapMode?t.wrapMode:33071===t.wrapMode.s&&t.wrapMode.t,t.hasMipmap)},e._applySamplingMode=function(e,t){var i=t.samplingMode,n=t.samplingMode;9985===i||9987===i?(i=9729,t.hasMipmap||(n=9729)):9984!==i&&9986!==i||(i=9728,t.hasMipmap||(n=9728)),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MAG_FILTER,i),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_MIN_FILTER,n)},e._applyWrapMode=function(e,t){"number"==typeof t.wrapMode?(e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,t.wrapMode),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,t.wrapMode)):(e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_S,t.wrapMode.s),e.texParameteri(e.TEXTURE_2D,e.TEXTURE_WRAP_T,t.wrapMode.t))},e._applyAnisotropicFilteringParameters=function(e,t){if(null!=t.maxAnisotropy){var i=e.capabilities.textureFilterAnisotropic;if(i){var n=e.gl;n.texParameterf(n.TEXTURE_2D,i.TEXTURE_MAX_ANISOTROPY,t.maxAnisotropy)}}},e._nextId=0,e}()}.apply(null,n))||(e.exports=r)},c8HX:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("BEeJ"),i("2ZMW"),i("66Fz"),i("Zp3t")],void 0===(r=function(e,t,i,n,r,a){return function(){function e(e,t,i){void 0===i&&(i=0),this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,this._pageWidth=e,this._pageHeight=t,i>0&&(this._maxItemSize=i),this._binPack=new r(e-4,t-4)}return e.prototype.getWidth=function(e){return e>=this._size.length?-1:this._size[e][0]},e.prototype.getHeight=function(e){return e>=this._size.length?-1:this._size[e][1]},e.prototype.setSpriteSource=function(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,0===this._mosaicsData.length){this._binPack=new r(this._pageWidth-4,this._pageHeight-4);var t=Math.floor(this._pageWidth),i=Math.floor(this._pageHeight),n=new Uint32Array(t*i);this._mosaicsData[0]=n,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e},e.prototype.getSpriteItem=function(e,t){void 0===t&&(t=!1);var i=this._mosaicRects[e];if(i)return i;if(!this._sprites||"loaded"!==this._sprites.loadStatus)return null;var n=this._sprites.getSpriteInfo(e);if(!n||!n.width||!n.height||n.width<0||n.height<0)return null;var r=n.width,a=n.height,o=this._allocateImage(r,a),s=o[0],l=o[1],d=o[2];return s.width<=0?null:(this._copy(s,n,l,d,t),i={rect:s,width:r,height:a,anchorX:0,anchorY:0,sdf:n.sdf,simplePattern:!1,pixelRatio:n.pixelRatio,page:l},this._mosaicRects[e]=i,i)},e.prototype.preloadSpriteItems=function(){for(var e=0,t=this._sprites.spriteNames;e<t.length;e++){var i=t[e];this.getSpriteItem(i,!0)}},e.prototype.getSpriteItems=function(e){for(var t={},i=0,n=e;i<n.length;i++){var r=n[i];t[r]=this.getSpriteItem(r)}return t},e.prototype.getMosaicItemPosition=function(e,t){var i=this.getSpriteItem(e,t),n=i&&i.rect;if(!n)return null;n.width=i.width,n.height=i.height;var r=i.width,a=i.height;return{size:[i.width,i.height],tl:[(n.x+2)/this._size[i.page][0],(n.y+2)/this._size[i.page][1]],br:[(n.x+2+r)/this._size[i.page][0],(n.y+2+a)/this._size[i.page][1]],page:i.page}},e.prototype.bind=function(e,t,i,n){void 0===i&&(i=0),void 0===n&&(n=0),this._textures[i]||(this._textures[i]=new a(e,{pixelFormat:6408,dataType:5121,width:this._size[i][0],height:this._size[i][1]},new Uint8Array(this._mosaicsData[i].buffer)));var r=this._textures[i];r.setSamplingMode(t),this._dirties[i]&&r.setData(new Uint8Array(this._mosaicsData[i].buffer)),e.bindTexture(r,n),this._dirties[i]=!1},e._copyBits=function(e,t,i,n,r,a,o,s,l,d,u){var c=n*t+i,f=s*a+o;if(u){f-=a;for(var h=-1;h<=d;c=((++h+d)%d+n)*t+i,f+=a)for(var _=-1;_<=l;_++)r[f+_]=e[c+(_+l)%l]}else for(h=0;h<d;h++){for(_=0;_<l;_++)r[f+_]=e[c+_];c+=t,f+=a}},e.prototype._copy=function(t,i,n,r,a,o){if(this._sprites&&"loaded"===this._sprites.loadStatus&&!(n>=this._mosaicsData.length)){var s=new Uint32Array(o?o.buffer:this._sprites.image.buffer),l=this._mosaicsData[n],d=o?i.width:this._sprites.width;e._copyBits(s,d,i.x,i.y,l,r[0],t.x+2,t.y+2,i.width,i.height,a),this._dirties[n]=!0}},e.prototype._allocateImage=function(e,t){e+=2,t+=2;var a=Math.max(e,t);if(this._maxItemSize&&this._maxItemSize<a){var o=Math.pow(2,Math.ceil(i.log2(e))),s=Math.pow(2,Math.ceil(i.log2(t))),l=new n(0,0,e,t);return this._mosaicsData.push(new Uint32Array(o*s)),this._dirties.push(!0),this._size.push([o,s]),this._textures.push(void 0),[l,this._mosaicsData.length-1,[o,s]]}var d=e%4?4-e%4:4,u=t%4?4-t%4:4;1===d&&(d=5),1===u&&(u=5);var c=this._binPack.allocate(e+d,t+u);return c.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new r(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,t)):[c,this._currentPage,[this._pageWidth,this._pageHeight]]},e.prototype.dispose=function(){this._binPack=null,this._mosaicRects={};for(var e=0,t=this._textures;e<t.length;e++){var i=t[e];i&&i.dispose()}this._textures.length=0},e}()}.apply(null,n))||(e.exports=r)},dHDC:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("j2SP"),i("BEeJ"),i("QFi0"),i("Zp3t"),i("z2+Q")],void 0===(r=function(e,t,i,n,r,a,o){return function(){function e(e){this._initialized=!1,this._color=i.vec4f32.fromValues(1,0,0,1),this._maxWidth=0,this._programOptions={id:!1,pattern:!1},this._programCache=e}return e.prototype.dispose=function(){this._outlineVertexArrayObject&&(this._outlineVertexArrayObject.dispose(),this._outlineVertexArrayObject=null),this._tileInfoVertexArrayObject&&(this._tileInfoVertexArrayObject.dispose(),this._tileInfoVertexArrayObject=null)},e.prototype.render=function(e,t){this._initialized||this._initialize(e);var i=this._programCache.getProgram(0,0,this._programOptions);if(i){e.bindVAO(this._outlineVertexArrayObject),e.bindProgram(i),i.setUniformMatrix4fv("u_transformMatrix",t.tileTransform.transform),i.setUniform2fv("u_normalized_origin",t.tileTransform.displayCoord),i.setUniform1f("u_coord_range",t.coordRange),i.setUniform1f("u_depth",0),i.setUniform4fv("u_color",this._color),e.drawArrays(3,0,4),e.bindVAO();var n=this._getTexture(e,t);if(n){var r=this._programCache.getProgram(7,0,null);r&&(e.bindVAO(this._tileInfoVertexArrayObject),e.bindProgram(r),e.bindTexture(n,0),r.setUniformMatrix4fv("u_transformMatrix",t.tileTransform.transform),r.setUniform2fv("u_normalized_origin",t.tileTransform.displayCoord),r.setUniform1f("u_depth",0),r.setUniform1f("u_coord_ratio",t.coordRange/512),r.setUniform2f("u_delta",8,8),r.setUniform2f("u_dimensions",n.descriptor.width,n.descriptor.height),e.drawArrays(5,0,4),e.bindVAO())}}},e.prototype._initialize=function(e){if(this._initialized)return!0;var t={geometry:[{name:"a_pos",count:2,type:5120,offset:0,stride:2,normalized:!1,divisor:0}]},i=new Int8Array([0,0,1,0,1,1,0,1]),n=r.createVertex(e,35044,i),a=new o(e,this._programCache.getProgramAttributes(0),t,{geometry:n}),s=new Int8Array([0,0,1,0,0,1,1,1]),l=r.createVertex(e,35044,s),d=new o(e,this._programCache.getProgramAttributes(7),t,{geometry:l});return this._outlineVertexArrayObject=a,this._tileInfoVertexArrayObject=d,this._initialized=!0,!0},e.prototype._getTexture=function(e,t){if(t.texture)return t.texture;this._canvas||(this._canvas=document.createElement("canvas"),this._canvas.setAttribute("id","canvas2d"),this._canvas.setAttribute("width","256"),this._canvas.setAttribute("height","32"),this._canvas.setAttribute("style","display:none"));var i=t.key.id,r=this._canvas.getContext("2d");r.font="24px sans-serif",r.textAlign="left",r.textBaseline="middle";var o=r.measureText(i),s=Math.pow(2,Math.ceil(n.log2(o.width+2)));return s>this._maxWidth&&(this._maxWidth=s),r.clearRect(0,0,this._maxWidth,32),r.fillStyle="blue",r.fillStyle="red",r.fillText(i,0,16),t.texture=new a(e,{target:3553,pixelFormat:6408,dataType:5121,samplingMode:9728},this._canvas),t.texture},e}()}.apply(null,n))||(e.exports=r)},hPTP:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("Uu9s"),i("IROT")],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=new n(function(e){var t=i;return e.split("/").forEach(function(e){t&&(t=t[e])}),t});t.resolveIncludes=function(e){return r.resolveIncludes(e)}}.apply(null,n))||(e.exports=r)},hmBC:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("Ak4l"),i("IROT")],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=new n(function(e){var t=i;return e.split("/").forEach(function(e){t&&(t=t[e])}),t});t.resolveIncludes=function(e){return r.resolveIncludes(e)}}.apply(null,n))||(e.exports=r)},j2SP:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("3gjc")],void 0===(r=function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0}),t.vec4f32=i}.apply(null,n))||(e.exports=r)},jImx:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("y1Ek"),i("U+8K")],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=function(){function e(){this._cache=new Array(8);for(var e=0;e<8;e++)this._cache[e]={}}return e.prototype.dispose=function(){this._programRepo&&(this._programRepo.dispose(),this._programRepo=null)},e.prototype.getProgram=function(e,t,i){var n=this._cache[e];if(!n[t]){var r=this._programRepo.getProgram(this._getProgramTemplate(e),i);n[t]=r}return n[t]},e.prototype.getProgramAttributes=function(e){switch(e){case 0:return i.background.attributes;case 5:return i.circle.attributes;case 1:return i.fill.attributes;case 4:return i.icon.attributes;case 3:return i.line.attributes;case 2:return i.outline.attributes;case 6:return i.text.attributes;case 7:return i.tileInfo.attributes}},e.prototype.initialize=function(e){this._programRepo||(this._programRepo=new n.ProgramCache(e))},e.prototype._getProgramTemplate=function(e){switch(e){case 0:return i.background;case 5:return i.circle;case 1:return i.fill;case 4:return i.icon;case 3:return i.line;case 2:return i.outline;case 6:return i.text;case 7:return i.tileInfo}},e}();t.default=r}.apply(null,n))||(e.exports=r)},"lOe/":function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("VCyw")],void 0===(r=function(e,t,i){Object.defineProperty(t,"__esModule",{value:!0});var n=function(e,t,i,n){this.fadeSpeed=e,this.minfadeLevel=t,this.maxfadeLevel=i,this.fadeChange=n};t.FadeProperties=n;var r=function(){function e(e){void 0===e&&(e=300),this._levelSnapshots=[],this._duration=e}return e.prototype.recordLevel=function(e){var t=i(),n=this._levelSnapshots;0===n.length&&(n.push({level:e,now:0}),n.push({level:e,now:0})),2!==n.length&&n[0].level===e||n.push({level:e,now:t})},e.prototype.needsRedraw=function(){if(0===this._levelSnapshots.length)return!1;for(var e=this._duration,t=this._levelSnapshots,i=t.length,n=t[i-1],r=-1;i>r+1&&t[r+1].now+e<n.now;)r++;for(r<0&&(r=0);r<i;r++)if(t[r].level!==n.level)return!0;return!1},e.prototype.getFadeValues=function(e){void 0===e&&(e=!1);for(var t=this._duration,n=i(),r=this._levelSnapshots;r.length>3&&r[1].now+t<n;)r.shift();r[1].now+t<n&&(r[0].level=r[1].level);var a=r[0].level,o=r[r.length-1],s=o.level,l=Math.min(a,s),d=Math.max(a,s),u=(o.level-r[1].level)/((o.now-r[1].now)/t),c=(n-o.now)/t*u;return e?{fadeSpeed:0,minfadeLevel:l,maxfadeLevel:d,fadeChange:0}:{fadeSpeed:u,minfadeLevel:l,maxfadeLevel:d,fadeChange:c}},e}();t.FadeRecorder=r}.apply(null,n))||(e.exports=r)},"lr+P":function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){Object.defineProperty(t,"__esModule",{value:!0});var i=new Uint32Array(1),n=new Uint8Array(i.buffer);t.int32To4Bytes=function(e){return i[0]=0|e,[n[0],n[1],n[2],n[3]]}}.apply(null,n))||(e.exports=r)},meDW:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("YX1r"),i("lgZd"),i("FXVB"),i("oZZu"),i("vlC2"),i("j2SP"),i("BEeJ"),i("lr+P"),i("z2+Q")],void 0===(r=function(e,t,i,n,r,a,o,s,l,d,u){return function(){function e(e){this._viewProjMat=a.mat4f32.create(),this._offsetVector=o.vec3f32.create(),this._patternMatrix=n.mat3f32.create(),this._color=s.vec4f32.create(),this._outlineColor=s.vec4f32.create(),this._initialized=!1,this._fillProgramOptions={id:!1,dd:!1,pattern:!1},this._outlineProgramOptions={id:!1,dd:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,i,n,a,o,s,u,c,f,h){if(0!==t.triangleElementCount){this._initialized||this._initialize(e);var _=void 0!==s.getPaintValue("fill-pattern",i),p=s.hasDataDrivenColor?[1,1,1,1]:s.getPaintValue("fill-color",i),m=s.hasDataDrivenOpacity?1:s.getPaintValue("fill-opacity",i),v=m*p[3]*h;this._color[0]=v*p[0],this._color[1]=v*p[1],this._color[2]=v*p[2],this._color[3]=v;var g,x=3===a;x&&(g=d.int32To4Bytes(t.layerID));var y=o.tileTransform.transform,b=o.coordRange/512,w=s.getPaintValue("fill-translate",i);if(0!==w[0]||0!==w[1]){r.mat4.copy(this._viewProjMat,o.tileTransform.transform);var D=w[0],T=w[1],V=0,A=0,S=(1<<o.key.level)/Math.pow(2,i)*b;if(1===s.getPaintValue("fill-translate-anchor",i)){var I=-l.C_DEG_TO_RAD*n,z=Math.sin(I),M=Math.cos(I);V=S*(D*M-T*z),A=S*(D*z+T*M)}else V=S*D,A=S*T;this._offsetVector[0]=V,this._offsetVector[1]=A,this._offsetVector[2]=0,r.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),y=this._viewProjMat}if(this._drawFill(e,t,i,a,o,s,u,y,f,h,x,g),s.getPaintValue("fill-antialias",i)&&!_&&t.outlineElementCount>0&&(1===a||3===a)){var C=s.hasDataDrivenOutline;if(s.outlineUsesFillColor){if(1!==this._color[3])return;this._outlineColor[0]=this._color[0],this._outlineColor[1]=this._color[1],this._outlineColor[2]=this._color[2],this._outlineColor[3]=this._color[3]}else{var E=s.hasDataDrivenOutlineColor?[1,1,1,1]:s.getPaintValue("fill-outline-color",i),R=m*E[3]*h;this._outlineColor[0]=R*E[0],this._outlineColor[1]=R*E[1],this._outlineColor[2]=R*E[2],this._outlineColor[3]=R}var O=.75/f,P=this._getOutlineVAO(e,o,C);if(P){e.bindVAO(P);var F=(x?1:0)<<1|(C?1:0),k=this._outlineProgramOptions;k.id=x,k.dd=C;var B=this._programCache.getProgram(2,F,k);e.bindProgram(B),B.setUniformMatrix4fv("u_transformMatrix",y),B.setUniformMatrix4fv("u_extrudeMatrix",c),B.setUniform2fv("u_normalized_origin",o.tileTransform.displayCoord),B.setUniform1f("u_depth",s.z+1/65536),B.setUniform1f("u_outline_width",O),B.setUniform4fv("u_color",this._outlineColor),x&&B.setUniform4f("u_id",g[0],g[1],g[2],g[3]),e.drawElements(4,t.outlineElementCount,5125,12*t.outlineElementStart),e.bindVAO()}}}},e.prototype._initialize=function(e){return!!this._initialized||(this._fillVertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:4,normalized:!1,divisor:0}]},this._fillVertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:8,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:4,stride:8,normalized:!0,divisor:0}]},this._outlineVertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:8,normalized:!1,divisor:0},{name:"a_offset",count:2,type:5120,offset:4,stride:8,normalized:!1,divisor:0},{name:"a_xnormal",count:2,type:5120,offset:6,stride:8,normalized:!1,divisor:0}]},this._outlineVertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:12,normalized:!1,divisor:0},{name:"a_offset",count:2,type:5120,offset:4,stride:12,normalized:!1,divisor:0},{name:"a_xnormal",count:2,type:5120,offset:6,stride:12,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:8,stride:12,normalized:!0,divisor:0}]},this._initialized=!0,!0)},e.prototype._drawFill=function(e,t,n,r,a,o,s,l,d,u,c,f){var h=o.getPaintValue("fill-pattern",n),_=void 0!==h,p=o.hasDataDrivenOpacity?1:u*o.getPaintValue("fill-opacity",n),m=o.hasDataDrivenColor?[1,1,1,1]:o.getPaintValue("fill-color",n),v=p*m[3]*u;this._color[0]=v*m[0],this._color[1]=v*m[1],this._color[2]=v*m[2],this._color[3]=v;var g=o.hasDataDrivenFill,x=_||v<1||g;if((!x||0!==r)&&(x||1!==r)){var y=this._getFillVAO(e,a,g);if(y){e.bindVAO(y);var b=(c?1:0)<<2|(g?1:0)<<1|(_?1:0),w=this._fillProgramOptions;w.id=c,w.dd=g,w.pattern=_;var D=this._programCache.getProgram(1,b,w);if(e.bindProgram(D),_){var T=s.getMosaicItemPosition(h,!0);if(!T)return e.bindVAO(),void e.bindProgram();var V=a.coordRange/512/Math.pow(2,Math.round(n)-a.key.level)/d;i.mat3.identity(this._patternMatrix);var A=1/(T.size[0]*V),S=1/(T.size[1]*V);this._patternMatrix[0]=A,this._patternMatrix[4]=S,s.bind(e,9729,T.page,5),D.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix),D.setUniform2f("u_pattern_tl",T.tl[0],T.tl[1]),D.setUniform2f("u_pattern_br",T.br[0],T.br[1]),D.setUniform1i("u_texture",5)}D.setUniformMatrix4fv("u_transformMatrix",l),D.setUniform2fv("u_normalized_origin",a.tileTransform.displayCoord),D.setUniform1f("u_depth",o.z+1/65536),D.setUniform4fv("u_color",this._color),c&&D.setUniform4f("u_id",f[0],f[1],f[2],f[3]),e.drawElements(4,t.triangleElementCount,5125,12*t.triangleElementStart),e.bindVAO()}}},e.prototype._getFillVAO=function(e,t,i){if(i){if(t.fillDDVertexArrayObject)return t.fillDDVertexArrayObject;var n=t.fillDDVertexBuffer,r=t.fillIndexBuffer;return n&&r?(t.fillDDVertexArrayObject=new u(e,this._programCache.getProgramAttributes(1),this._fillVertexAttributesDD,{geometry:n},r),t.fillDDVertexArrayObject):null}if(t.fillVertexArrayObject)return t.fillVertexArrayObject;n=t.fillVertexBuffer,r=t.fillIndexBuffer;return n&&r?(t.fillVertexArrayObject=new u(e,this._programCache.getProgramAttributes(1),this._fillVertexAttributes,{geometry:n},r),t.fillVertexArrayObject):null},e.prototype._getOutlineVAO=function(e,t,i){if(i){if(t.outlineDDVertexArrayObject)return t.outlineDDVertexArrayObject;var n=t.outlineDDVertexBuffer,r=t.outlineIndexBuffer;return n&&r?(t.outlineDDVertexArrayObject=new u(e,this._programCache.getProgramAttributes(2),this._outlineVertexAttributesDD,{geometry:n},r),t.outlineDDVertexArrayObject):null}if(t.outlineVertexArrayObject)return t.outlineVertexArrayObject;n=t.outlineVertexBuffer,r=t.outlineIndexBuffer;return n&&r?(t.outlineVertexArrayObject=new u(e,this._programCache.getProgramAttributes(2),this._outlineVertexAttributes,{geometry:n},r),t.outlineVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},suZm:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("H1tY"),i("FXVB"),i("oZZu"),i("ab6c"),i("vlC2"),i("j2SP"),i("BEeJ"),i("lr+P"),i("z2+Q")],void 0===(r=function(e,t,i,n,r,a,o,s,l,d,u){return function(){function e(e){this._viewProjMat=r.mat4f32.create(),this._offsetVector=o.vec3f32.create(),this._extrudeMat=r.mat4f32.create(),this._scaleVec=o.vec3f32.create(),this._haloColor=s.vec4f32.create(),this._sdfColor=s.vec4f32.create(),this._initialized=!1,this._programOptions={id:!1,dd:!1},this._programCache=e}return e.prototype.dispose=function(){},e.prototype.render=function(e,t,r,o,s,u,c,f,h,_,p,m,v){var g=this;if(!i("esri-vector-tiles-avoid-text")){this._initialized||this._initialize(e);var x=l.degToByte(s),y=f.getLayoutValue("text-rotation-alignment",r);2===y&&(y=1===f.getLayoutValue("symbol-placement",r)?0:1);var b=0===y,w=f.getLayoutValue("text-keep-upright",r)&&b,D=3===o,T=.8*3/m,V=f.hasDataDrivenTextSize?1:f.getLayoutValue("text-size",r),A=f.hasDataDrivenTextColor?[1,1,1,1]:f.getPaintValue("text-color",r),S=f.hasDataDrivenTextOpacity?1:f.getPaintValue("text-opacity",r),I=A[3]*S*v;this._sdfColor[0]=I*A[0],this._sdfColor[1]=I*A[1],this._sdfColor[2]=I*A[2],this._sdfColor[3]=I,this._glyphTextureSize||(this._glyphTextureSize=a.vec2f32.fromValues(h.width/4,h.height/4));var z=c.tileTransform.transform,M=f.getPaintValue("text-translate",r);if(0!==M[0]||0!==M[1]){n.mat4.copy(this._viewProjMat,c.tileTransform.transform);var C=M[0],E=M[1],R=0,O=0,P=c.coordRange/512,F=(1<<c.key.level)/Math.pow(2,r)*P;if(1===f.getPaintValue("text-translate-anchor",r)){var k=-l.C_DEG_TO_RAD*s,B=Math.sin(k),U=Math.cos(k);R=F*(C*U-E*B),O=F*(C*B+E*U)}else R=F*C,O=F*E;this._offsetVector[0]=R,this._offsetVector[1]=O,this._offsetVector[2]=0,n.mat4.translate(this._viewProjMat,this._viewProjMat,this._offsetVector),z=this._viewProjMat}b?n.mat4.copy(this._extrudeMat,_):n.mat4.copy(this._extrudeMat,p),this._scaleVec[0]=1/24,this._scaleVec[1]=1/24,this._scaleVec[2]=1,n.mat4.scale(this._extrudeMat,this._extrudeMat,this._scaleVec);var L=f.hasDataDrivenText,N=this._getSDFVAO(e,c,L);if(N){e.bindVAO(N);var j=(D?1:0)<<1|(L?1:0),H=this._programOptions;H.id=D,H.dd=L;var W=this._programCache.getProgram(6,j,H);if(e.bindProgram(W),W.setUniformMatrix4fv("u_transformMatrix",z),W.setUniformMatrix4fv("u_extrudeMatrix",this._extrudeMat),W.setUniform2fv("u_normalized_origin",c.tileTransform.displayCoord),W.setUniform1f("u_depth",f.z+1/65536),W.setUniform2fv("u_mosaicSize",this._glyphTextureSize),W.setUniform1f("u_mapRotation",x),W.setUniform1f("u_keepUpright",w?1:0),W.setUniform1f("u_level",10*r),W.setUniform1f("u_fadeSpeed",10*u.fadeSpeed),W.setUniform1f("u_minfadeLevel",10*u.minfadeLevel),W.setUniform1f("u_maxfadeLevel",10*u.maxfadeLevel),W.setUniform1f("u_fadeChange",10*(r+u.fadeChange)),W.setUniform1i("u_texture",6),W.setUniform1f("u_size",V),W.setUniform1f("u_antialiasingWidth",T),D){var G=d.int32To4Bytes(t.layerID);W.setUniform4f("u_id",G[0],G[1],G[2],G[3])}t.glyphPerPageElementsMap.forEach(function(t,i){g._renderGlyphRange(e,t,i,f,h,W,r,S*v,3)}),e.bindVAO()}}},e.prototype._renderGlyphRange=function(e,t,i,n,r,a,o,s,l){r.bind(e,9729,i,6);var d=n.getPaintValue("text-halo-color",o),u=n.getPaintValue("text-halo-width",o);if(d[3]>0&&u>0){var c=d[3]*s;this._haloColor[0]=c*d[0],this._haloColor[1]=c*d[1],this._haloColor[2]=c*d[2],this._haloColor[3]=c;var f=n.getPaintValue("text-halo-blur",o)*l,h=u*l;a.setUniform4fv("u_color",this._haloColor),a.setUniform1f("u_halo",1),a.setUniform1f("u_edgeDistance",h),a.setUniform1f("u_edgeBlur",f),e.drawElements(4,t[1],5125,12*t[0])}this._sdfColor[3]>0&&(a.setUniform4fv("u_color",this._sdfColor),a.setUniform1f("u_halo",0),a.setUniform1f("u_edgeDistance",0),a.setUniform1f("u_edgeBlur",0),e.drawElements(4,t[1],5125,12*t[0]))},e.prototype._initialize=function(e){return!!this._initialized||(this._vertexAttributes={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:16,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:16,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:16,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:16,normalized:!1,divisor:0}]},this._vertexAttributesDD={geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:24,normalized:!1,divisor:0},{name:"a_vertexOffset",count:2,type:5122,offset:4,stride:24,normalized:!1,divisor:0},{name:"a_tex",count:4,type:5121,offset:8,stride:24,normalized:!1,divisor:0},{name:"a_levelInfo",count:4,type:5121,offset:12,stride:24,normalized:!1,divisor:0},{name:"a_color",count:4,type:5121,offset:16,stride:24,normalized:!0,divisor:0},{name:"a_size",count:1,type:5126,offset:20,stride:24,normalized:!1,divisor:0}]},this._initialized=!0,!0)},e.prototype._getSDFVAO=function(e,t,i){if(i){if(t.textDDVertexArrayObject)return t.textDDVertexArrayObject;var n=t.textDDVertexBuffer,r=t.textIndexBuffer;return n&&r?(t.textDDVertexArrayObject=new u(e,this._programCache.getProgramAttributes(6),this._vertexAttributesDD,{geometry:n},r),t.textDDVertexArrayObject):null}if(t.textVertexArrayObject)return t.textVertexArrayObject;n=t.textVertexBuffer,r=t.textIndexBuffer;return n&&r?(t.textVertexArrayObject=new u(e,this._programCache.getProgramAttributes(6),this._vertexAttributes,{geometry:n},r),t.textVertexArrayObject):null},e}()}.apply(null,n))||(e.exports=r)},v4bN:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("YX1r"),i("lgZd"),i("j2SP"),i("U+RI"),i("lr+P"),i("QFi0"),i("z2+Q")],void 0===(r=function(e,t,i,n,r,a,o,s,l){return function(){function e(e){this._patternMatrix=n.mat3f32.create(),this._color=r.vec4f32.create(),this._solidrendererInitialized=!1,this._rendererInitialized=!1,this._programOptions={id:!1,pattern:!1},this._programCache=e,this._color.set([1,0,0,1])}return e.prototype.dispose=function(){this._solidVertexArrayObject&&(this._solidVertexArrayObject.dispose(),this._solidVertexArrayObject=null),this._vertexArrayObject&&(this._vertexArrayObject.dispose(),this._vertexArrayObject=null)},e.prototype.renderSolidColor=function(e,t){this._solidrendererInitialized||this._initializeSolidRenderer(e),e.bindVAO(this._solidVertexArrayObject);var i=this._programOptions;i.id=!1,i.pattern=!1;var n=this._programCache.getProgram(0,0,i);e.bindProgram(n),n.setUniformMatrix4fv("u_transformMatrix",t.u_matrix),n.setUniform2fv("u_normalized_origin",t.u_normalized_origin),n.setUniform1f("u_coord_range",t.u_coord_range||4096),n.setUniform1f("u_depth",t.u_depth||0),n.setUniform4fv("u_color",t.u_color||this._color),e.drawArrays(5,0,4),e.bindVAO()},e.prototype.render=function(e,t,n,r,a,s,l,d,u){this._rendererInitialized||this._initialize(e);var c=s.getPaintValue("background-color",n),f=u*s.getPaintValue("background-opacity",n),h=s.getPaintValue("background-pattern",n),_=void 0!==h,p=c[3]*f,m=_||p<1;if((!m||0!==r)&&(m||1!==r)){var v=3===r,g=(v?1:0)<<1|(_?1:0),x=this._programOptions;x.id=v,x.pattern=_;var y=this._programCache.getProgram(0,g,x);if(e.bindVAO(this._vertexArrayObject),e.bindProgram(y),y.setUniform1f("u_coord_range",a.coordRange),y.setUniform1f("u_depth",s.z||0),y.setUniformMatrix4fv("u_transformMatrix",a.tileTransform.transform),y.setUniform2fv("u_normalized_origin",a.tileTransform.displayCoord),_){var b=l.getMosaicItemPosition(h,!0);if(!b)return;var w=512*Math.pow(2,Math.floor(n)-a.key.level)*d;i.mat3.identity(this._patternMatrix);var D=w/b.size[0],T=w/b.size[1];this._patternMatrix[0]=D,this._patternMatrix[4]=T,l.bind(e,9729,b.page,5),y.setUniformMatrix3fv("u_pattern_matrix",this._patternMatrix),y.setUniform1f("u_opacity",f),y.setUniform2f("u_pattern_tl",b.tl[0],b.tl[1]),y.setUniform2f("u_pattern_br",b.br[0],b.br[1]),y.setUniform1i("u_texture",5)}else this._color[0]=p*c[0],this._color[1]=p*c[1],this._color[2]=p*c[2],this._color[3]=p,y.setUniform4fv("u_color",this._color);if(v){var V=o.int32To4Bytes(t.layerID);y.setUniform4f("u_id",V[0],V[1],V[2],V[3])}e.drawArrays(5,0,4),e.bindVAO()}},e.prototype._initializeSolidRenderer=function(e){if(this._solidrendererInitialized)return!0;var t=new Int8Array([0,0,1,0,0,1,1,1]),i=s.createVertex(e,35044,t),n=new l(e,this._programCache.getProgramAttributes(0),{geometry:[{name:"a_pos",count:2,type:5120,offset:0,stride:2,normalized:!1,divisor:0}]},{geometry:i});return this._solidVertexArrayObject=n,this._solidrendererInitialized=!0,!0},e.prototype._initialize=function(e){if(this._rendererInitialized)return!0;var t=[];t.push(a.i1616to32(0,0)),t.push(a.i1616to32(1,0)),t.push(a.i1616to32(0,1)),t.push(a.i1616to32(1,1));var i=new Uint32Array(t),n=s.createVertex(e,35044,i),r=new l(e,{a_pos:0},{geometry:[{name:"a_pos",count:2,type:5122,offset:0,stride:4,normalized:!1,divisor:0}]},{geometry:n});return this._vertexArrayObject=r,this._rendererInitialized=!0,!0},e}()}.apply(null,n))||(e.exports=r)},v7zm:function(e,t,i){var n,r;n=[i.dj.c(e.i),t],void 0===(r=function(e,t){return function(){function e(e,t,i,n){this._tag=0,this._dataType=99,this._data=e,this._dataView=t,this._pos=i||0,this._end=n||e.byteLength}return e.prototype.clone=function(){return new e(this._data,this._dataView,this._pos,this._end)},e.prototype.pos=function(){return this._pos},e.prototype.next=function(e){for(;;){if(this._pos===this._end)return!1;var t=this._decodeVarint();if(this._tag=t>>3,this._dataType=7&t,!e||e===this._tag)break;this.skip()}return!0},e.prototype.empty=function(){return this._pos>=this._end},e.prototype.tag=function(){return this._tag},e.prototype.getInt32=function(){return this._decodeVarint()},e.prototype.getInt64=function(){return this._decodeVarint()},e.prototype.getUInt32=function(){var e=4294967295;return e=(127&this._data[this._pos])>>>0,this._data[this._pos++]<128?e:(e=(e|(127&this._data[this._pos])<<7)>>>0,this._data[this._pos++]<128?e:(e=(e|(127&this._data[this._pos])<<14)>>>0,this._data[this._pos++]<128?e:(e=(e|(127&this._data[this._pos])<<21)>>>0,this._data[this._pos++]<128?e:(e=(e|(15&this._data[this._pos])<<28)>>>0,this._data[this._pos++]<128?e:void 0))))},e.prototype.getUInt64=function(){return this._decodeVarint()},e.prototype.getSInt32=function(){var e=this.getUInt32();return e>>>1^-(1&e)|0},e.prototype.getSInt64=function(){return this._decodeSVarint()},e.prototype.getBool=function(){var e=0!==this._data[this._pos];return this._skip(1),e},e.prototype.getEnum=function(){return this._decodeVarint()},e.prototype.getFixed64=function(){var e=this._dataView,t=this._pos,i=e.getUint32(t,!0)+4294967296*e.getUint32(t+4,!0);return this._skip(8),i},e.prototype.getSFixed64=function(){var e=this._dataView,t=this._pos,i=e.getUint32(t,!0)+4294967296*e.getInt32(t+4,!0);return this._skip(8),i},e.prototype.getDouble=function(){var e=this._dataView.getFloat64(this._pos,!0);return this._skip(8),e},e.prototype.getFixed32=function(){var e=this._dataView.getUint32(this._pos,!0);return this._skip(4),e},e.prototype.getSFixed32=function(){var e=this._dataView.getInt32(this._pos,!0);return this._skip(4),e},e.prototype.getFloat=function(){var e=this._dataView.getFloat32(this._pos,!0);return this._skip(4),e},e.prototype.getString=function(){var e=this._getLength(),t=this._pos,i=this._toString(this._data,t,t+e);return this._skip(e),i},e.prototype.getBytes=function(){var e=this._getLength(),t=this._pos,i=this._toBytes(this._data,t,t+e);return this._skip(e),i},e.prototype.getMessage=function(){var t=this._getLength(),i=this._pos,n=new e(this._data,this._dataView,i,i+t);return this._skip(t),n},e.prototype.skip=function(){switch(this._dataType){case 0:this._decodeVarint();break;case 1:this._skip(8);break;case 2:this._skip(this._getLength());break;case 5:this._skip(4);break;default:throw new Error("Invalid data type!")}},e.prototype._skip=function(e){if(this._pos+e>this._end)throw new Error("Attempt to skip past the end of buffer!");this._pos+=e},e.prototype._decodeVarint=function(){var e,t=this._data,i=this._pos,n=0;if(this._end-i>=10)do{if(n|=127&(e=t[i++]),0==(128&e))break;if(n|=(127&(e=t[i++]))<<7,0==(128&e))break;if(n|=(127&(e=t[i++]))<<14,0==(128&e))break;if(n|=(127&(e=t[i++]))<<21,0==(128&e))break;if(n+=268435456*(127&(e=t[i++])),0==(128&e))break;if(n+=34359738368*(127&(e=t[i++])),0==(128&e))break;if(n+=4398046511104*(127&(e=t[i++])),0==(128&e))break;if(n+=562949953421312*(127&(e=t[i++])),0==(128&e))break;if(n+=72057594037927940*(127&(e=t[i++])),0==(128&e))break;if(n+=0x8000000000000000*(127&(e=t[i++])),0==(128&e))break;throw new Error("Varint too long!")}while(0);else{for(var r=1;i!==this._end&&0!=(128&(e=t[i]));)++i,n+=(127&e)*r,r*=128;if(i===this._end)throw new Error("Varint overrun!");++i,n+=e*r}return this._pos=i,n},e.prototype._decodeSVarint=function(){var e=this._decodeVarint();return e%2?-(e+1)/2:e/2},e.prototype._getLength=function(){if(2!==this._dataType)throw new Error("Not a delimited data type!");return this._decodeVarint()},e.prototype._toString=function(e,t,i){var n="",r="";i=Math.min(this._end,i);for(var a=t;a<i;++a){var o=e[a];128&o?r+="%"+o.toString(16):(n+=decodeURIComponent(r)+String.fromCharCode(o),r="")}return r.length&&(n+=decodeURIComponent(r)),n},e.prototype._toBytes=function(e,t,i){return i=Math.min(this._end,i),new Uint8Array(e.buffer,t,i-t)},e}()}.apply(null,n))||(e.exports=r)},y1Ek:function(e,t,i){var n,r;n=[i.dj.c(e.i),t,i("hmBC"),i("U+8K")],void 0===(r=function(e,t,i,n){Object.defineProperty(t,"__esModule",{value:!0});var r=function(e){return n.glslifyDefineMap({ID:e.id,PATTERN:e.pattern})};t.background={name:"background",shaders:function(e){return{vertexShader:r(e)+i.resolveIncludes("background/background.vert"),fragmentShader:r(e)+i.resolveIncludes("background/background.frag")}},attributes:{a_pos:0}};var a=function(e){return n.glslifyDefineMap({ID:e.id})};t.circle={name:"circle",shaders:function(e){return{vertexShader:a(e)+i.resolveIncludes("circle/circle.vert"),fragmentShader:a(e)+i.resolveIncludes("circle/circle.frag")}},attributes:{a_pos:0,a_color:1,a_stroke_color:2,a_data:3}};var o=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd,PATTERN:e.pattern})};t.fill={name:"fill",shaders:function(e){return{vertexShader:o(e)+i.resolveIncludes("fill/fill.vert"),fragmentShader:o(e)+i.resolveIncludes("fill/fill.frag")}},attributes:{a_pos:0,a_color:1}};var s=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd})};t.outline={name:"outline",shaders:function(e){return{vertexShader:s(e)+i.resolveIncludes("outline/outline.vert"),fragmentShader:s(e)+i.resolveIncludes("outline/outline.frag")}},attributes:{a_pos:0,a_offset:1,a_xnormal:2,a_color:3}};var l=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd,SDF:e.sdf})};t.icon={name:"icon",shaders:function(e){return{vertexShader:l(e)+i.resolveIncludes("icon/icon.vert"),fragmentShader:l(e)+i.resolveIncludes("icon/icon.frag")}},attributes:{a_pos:0,a_vertexOffset:1,a_tex:2,a_levelInfo:3,a_color:4,a_size:5}};var d=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd,PATTERN:e.pattern})};t.line={name:"line",shaders:function(e){return{vertexShader:d(e)+i.resolveIncludes("line/line.vert"),fragmentShader:d(e)+i.resolveIncludes("line/line.frag")}},attributes:{a_pos:0,a_offsetAndNormal:1,a_accumulatedDistance:2,a_color:3,a_width:4}};var u=function(e){return n.glslifyDefineMap({ID:e.id,DD:e.dd})};t.text={name:"text",shaders:function(e){return{vertexShader:u(e)+i.resolveIncludes("text/text.vert"),fragmentShader:u(e)+i.resolveIncludes("text/text.frag")}},attributes:{a_pos:0,a_vertexOffset:1,a_tex:2,a_levelInfo:3,a_color:4,a_size:5}},t.tileInfo={name:"tileInfo",shaders:{vertexShader:i.resolveIncludes("tileInfo/tileInfo.vert"),fragmentShader:i.resolveIncludes("tileInfo/tileInfo.frag")},attributes:{a_pos:0}}}.apply(null,n))||(e.exports=r)}}]);